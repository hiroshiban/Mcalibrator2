/* cbf_uncompress.c: 
 
   Compilation from Matlab:
   mex cbf_uncompress.c
   maybe a tiny bit faster code is generated by 
   mex -O COPTIMFLAGS='-O2' LDOPTIMFLAGS='-O2' cbf_uncompress.c
 
   Usage from Matlab:
   [frame] = ...
       cbf_uncompress(dat_in,dim1,dim2,no_of_in_bytes,compression_type);
 
   history:
   April 24th 2008, Oliver Bunk: 
   1st version based on code snippet from Eric Eikenberry
*/

#include "mex.h"

#include <math.h> 
#include <stdio.h>

void mexFunction(int nlhs, mxArray *plhs[],
                 int nrhs, const mxArray *prhs[])
{
  const mxArray *curr_arg;
  union { 
    unsigned char *uint8;
             char *int8;
	unsigned short *uint16;
	         short *int16;
	unsigned int *uint32;
	         int *int32;
  } data_in,data_in_start;

  int dim1, dim2, no_of_in_bytes, compression_type;
  int diff, val_curr;
  double *frame_out, *frame_out_start;
  
    /* initialize return argument*/
  plhs[0] = NULL;
  
    /* Check for proper number of arguments. */
  if (nrhs != 5) 
    mexErrMsgTxt("Five input arguments required: dat_in,dim1,dim2,no_of_in_bytes,compression_type.");
  else if (nlhs != 1) 
    mexErrMsgTxt("One output argument has to be specified.");

  {
    int ind;
    for (ind = 0; ind < nrhs; ind++) {
      if(mxGetNumberOfDimensions(prhs[ind]) != 2) {
        printf("The %d. input argument must have two dimensions.",ind+1);
        mxErrMsgTxt("wrong number of dimensions");
      }
    }
  }
  
    /* check 1st input argument: input data */
  curr_arg = prhs[0];
  if (mxIsUint8(curr_arg) != 1)
    mexErrMsgTxt("Input 1 (input data) must be of type uint8.");
  data_in_start.uint8 = data_in.uint8 = (char *) mxGetPr(curr_arg);

    /* check 2nd input argument: dim1 */
  curr_arg = prhs[1];
  if (mxIsDouble(curr_arg) != 1)
    mexErrMsgTxt("Input 2 (dimension 1) must be of type double.");
  dim1 = mxGetScalar(curr_arg);
  if (dim1 < 1) {
    mexErrMsgTxt("Input 2 (dimension 1) must be at least 1.");
  }

    /* check 3rd input argument: dim2 */
  curr_arg = prhs[2];
  if (mxIsDouble(curr_arg) != 1)
    mexErrMsgTxt("Input 3 (dimension 2) must be of type double.");
  dim2 = mxGetScalar(curr_arg);
  if (dim2 < 1) {
    mexErrMsgTxt("Input 3 (dimension 2) must be at least 1.");
  }
  
    /* check 4th input argument: no_of_in_bytes */
  curr_arg = prhs[3];
  if (mxIsDouble(curr_arg) != 1)
    mexErrMsgTxt("Input 4 (no. of input bytes) must be of type double.");
  no_of_in_bytes = mxGetScalar(curr_arg);
  
    /* check 5th input argument: compression_type */
  curr_arg = prhs[4];
  if (mxIsDouble(curr_arg) != 1)
    mexErrMsgTxt("Input 5 (compression type) must be of type double.");
  compression_type = mxGetScalar(curr_arg);
  if (compression_type != 1) {
    mexErrMsgTxt("currently only compression type 1, byte-offset compression, is supported");
  }
  
    /* allocate memory for the output data */
  plhs[0] = mxCreateNumericMatrix(dim1, dim2, mxDOUBLE_CLASS, mxREAL);
  if (plhs[0] == NULL)
    mexErrMsgTxt("Could not allocate memory for return data.");
  frame_out_start = frame_out = mxGetPr(plhs[0]);

  val_curr = 0;
  while (data_in.uint8-data_in_start.uint8 < no_of_in_bytes) {
	if (*data_in.uint8 != 0x80) {
	  diff = (int) *data_in.int8++;
    } else {
  	  data_in.uint8++;
	  if (*data_in.uint16 != 0x8000) {
		diff = (int) *data_in.int16++;
      } else {
        data_in.uint16++;
		diff = (int) *data_in.int32++;
  	  }
    }
	val_curr += diff;
    *frame_out++ = (double) val_curr;
  }

  if (frame_out-frame_out_start != dim1*dim2) {
    printf("%ld bytes after uncompression, %ld bytes expected",
           frame_out-frame_out_start, dim1*dim2);
    mexErrMsgTxt("mismatch in number of extracted data bytes");
  }
  
  return;
}
