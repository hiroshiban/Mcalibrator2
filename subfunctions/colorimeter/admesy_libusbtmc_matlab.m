function [methodinfo,structs,enuminfo,ThunkLibName]=admesy_libusbtmc_matlab

% A MATLAB version of header file, admesy_usbtmc.h
% function [methodinfo,structs,enuminfo,ThunkLibName]=admesy_libusbtmc_matlab
%
% Created    : "2017-06-29 17:33:13 ban"
% Last Update: "2017-06-29 18:15:13 ban"
%
% [about]
% ADMESY_USBTMC_MATLAB Create structures to define interfaces found in 'admesy_usbtmc'.
% This is a MATLAB-based C-langurage prototype file required to use functions
% included in admesy_usbtmc.dll that controls admesy Brontes-LL from our own
% programs.
%
% [note]
% Generally, to load admesy_usbtmc.h with its DLL using 'loadlibrary' function as
% >> loadlibrary('admesy_usbtmc.dll','admesy_usbtmc.h','alias','usbtmc);
% will be fine. Of course, the header file 'admesy_usbtmc.h' is correct when it is loaded in C/C++.
%
% However, the way admesy_usbtmc.dll exposes its functions is not compatible with
% the calling convention that MATLAB expects (cdecl vs. stdcall). Thus, I modified
% admesy_usbtmc.h so that it is compatible with MATLAB convention.
% Then, I output new admesy_usbtmc_matlab to a MATLAB-based C-language prototype file using
% >> loadlibrary('libusbtmc_x64.dll','libusbtmc.h','alias','usbtmc','mfilename','admesy_libusbtmc_matlab');
%
% [original version of admesy_usbtmc.h]
%
% #ifndef _libsubtmc_H_
% #define _libsubtmc_H_
%
% //#if BUILDING_DLL
% # define DLLIMPORT __declspec (dllexport)
% //#else /* Not BUILDING_DLL */
% //# define DLLIMPORT __declspec (dllimport)
% //# define DLLIMPORT __declspec (dllexport)
% //#endif /* Not BUILDING_DLL */
%
%   #pragma once
%   #pragma managed(push)
%   #pragma unmanaged
%
% //export functions
% DLLIMPORT void usbtmc_get_version(char * usbtmcdevices);
% DLLIMPORT void usbtmc_init ();
% DLLIMPORT int usbtmc_find_devices (char * usbtmcdevices);
% DLLIMPORT int usbtmc_open(char * instrDescriptor, unsigned long *handle);
% DLLIMPORT int usbtmc_write (unsigned long *handle, char *command, int timeout);
% DLLIMPORT int usbtmc_read(unsigned long *handle, unsigned char *data, unsigned long bytecount, int timeout);
% DLLIMPORT int usbtmc_close (unsigned long *handle);
%
% //Error codes for Admesy_usbtmc
% #define ERROR_NOLIB					-20		//NO Library found
% #define ERROR_NOLIB_OPEN			-21		//NO Library opened
% #define ERROR_LIBUSB_EMTSTR			-22		//Vendorid or productid emty (only for LibUSB)
% #define NOVISADEVICES				-23		//
% #define LIBUSB_DEVICE_NOT_PRESENT	-24		//device is not present when opening
%
% //All other error codes are passed through
% //NI-VISA errors http://zone.ni.com/reference/en-XX/help/lv/71/lverror/VISA_Error_Codes/
% //Libusb errors http://libusb.sourceforge.net/api-1.0/group__misc.html
%
% 	#pragma managed(pop)
%
% #endif /* _DLL_H_ */

% This function was generated by loadlibrary.m parser version  on Thu Jun 29 16:58:31 2017
% perl options:'libusbtmc.i -outfile=admesy_libusbtmc_matlab_test.m -thunkfile=usbtmc_thunk_pcwin64.c -header=libusbtmc.h'

% initialization
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];
enuminfo=[];
fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'usbtmc_thunk_pcwin64');

% prototypes of functions included in libusbtmc_x{86|64}.dll

% void usbtmc_get_version ( char * usbtmcdevices );
fcns.thunkname{fcnNum}='voidcstringThunk';
fcns.name{fcnNum}='usbtmc_get_version';
fcns.calltype{fcnNum}='Thunk';
fcns.LHS{fcnNum}=[];
fcns.RHS{fcnNum}={'cstring'};
fcnNum=fcnNum+1;

% void usbtmc_init ();
fcns.thunkname{fcnNum}='voidThunk';
fcns.name{fcnNum}='usbtmc_init';
fcns.calltype{fcnNum}='Thunk';
fcns.LHS{fcnNum}=[];
fcns.RHS{fcnNum}=[];
fcnNum=fcnNum+1;

% int usbtmc_find_devices ( char * usbtmcdevices );
fcns.thunkname{fcnNum}='int32cstringThunk';
fcns.name{fcnNum}='usbtmc_find_devices';
fcns.calltype{fcnNum}='Thunk';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'cstring'};
fcnNum=fcnNum+1;

% int usbtmc_open ( char * instrDescriptor , unsigned long * handle );
fcns.thunkname{fcnNum}='int32cstringvoidPtrThunk';
fcns.name{fcnNum}='usbtmc_open';
fcns.calltype{fcnNum}='Thunk';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'cstring', 'ulongPtr'};
fcnNum=fcnNum+1;

% int usbtmc_write ( unsigned long * handle , char * command , int timeout );
fcns.thunkname{fcnNum}='int32voidPtrcstringint32Thunk';
fcns.name{fcnNum}='usbtmc_write';
fcns.calltype{fcnNum}='Thunk';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'ulongPtr', 'cstring', 'int32'};
fcnNum=fcnNum+1;

% int usbtmc_read ( unsigned long * handle , unsigned char * data , unsigned long bytecount , int timeout );
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrulongint32Thunk';
fcns.name{fcnNum}='usbtmc_read';
fcns.calltype{fcnNum}='Thunk';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'ulongPtr', 'uint8Ptr', 'ulong', 'int32'};
fcnNum=fcnNum+1;

% int usbtmc_close ( unsigned long * handle );
fcns.thunkname{fcnNum}='int32voidPtrThunk';
fcns.name{fcnNum}='usbtmc_close';
fcns.calltype{fcnNum}='Thunk';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'ulongPtr'};
fcnNum=fcnNum+1;

methodinfo=fcns;

return
