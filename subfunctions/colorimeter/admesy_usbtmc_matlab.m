function [methodinfo,structs,enuminfo,ThunkLibName]=admesy_usbtmc_matlab

% A MATLAB version of header file, admesy_usbtmc.h
% function [methodinfo,structs,enuminfo,ThunkLibName]=admesy_usbtmc_matlab
%
% Created    : "2012-10-30 20:02:11 banh"
% Last Update: "2013-12-11 17:50:30 ban"
%
% [about]
% ADMESY_USBTMC_MATLAB Create structures to define interfaces found in 'admesy_usbtmc'.
% This is a MATLAB-based C-langurage prototype file required to use functions
% included in admesy_usbtmc.dll that controls admesy Brontes-LL from our own
% programs.
%
% [note]
% Generally, to load admesy_usbtmc.h with its DLL using 'loadlibrary' function as
% >> loadlibrary('admesy_usbtmc.dll','admesy_usbtmc.h','alias','usbtmc);
% will be fine. Of course, the header file 'admesy_usbtmc.h' is correct when it is loaded in C/C++.
%
% However, the way admesy_usbtmc.dll exposes its functions is not compatible with
% the calling convention that MATLAB expects (cdecl vs. stdcall). Thus, I modified
% admesy_usbtmc.h so that it is compatible with MATLAB convention.
% Then, I output new admesy_usbtmc_matlab to a MATLAB-based C-language prototype file using
% >> loadlibrary('admesy_usbtmc.dll','admesy_usbtmc.h','alias','usbtmc','mfilename','admesy_usbtmc_matlab');
%
% [original version of admesy_usbtmc.h]
%
% #ifndef _DLL_H_
% #define _DLL_H_
%
% #if BUILDING_DLL
% # define DLLIMPORT __declspec (dllexport)
% #else /* Not BUILDING_DLL */
% # define DLLIMPORT __declspec (dllimport)
% #endif /* Not BUILDING_DLL */
%
% //export functions
% DLLIMPORT int usbtmc_find_devices (char * usbtmcdevices);
% DLLIMPORT int usbtmc_open(char * instrDescriptor, unsigned long * handle);
% DLLIMPORT int usbtmc_write (unsigned long * handle, char *command, int timeout);
% DLLIMPORT int usbtmc_read(unsigned long * handle, char *data, int timeout);
% DLLIMPORT int usbtmc_close (unsigned long * handle);
%
% //Error codes for Admesy_usbtmc
% #define ERROR_NOLIB          -20     //NO Library found
% #define ERROR_NOLIB_OPEN -21     //NO Library opened
% #define ERROR_LIBUSB_EMTSTR  -22     //Vendorid or productid emty (only for LibUSB)
%
% //All other error codes are passed through
% //NI-VISA errors http://zone.ni.com/reference/en-XX/help/lv/71/lverror/VISA_Error_Codes/
% //Libusb errors http://libusb.sourceforge.net/api-1.0/group__misc.html
%
% #endif /* _DLL_H_ */
%
% [modified version of admesy_usbtmc.h]
%
% #ifndef __ADMESY_USBTMC_h
% #define __ADMESY_USBTMC_h
%
% #ifdef __cplusplus
% extern "C" {
% #endif
%
% //export functions
% __stdcall int usbtmc_find_devices (char * usbtmcdevices);
% __stdcall int usbtmc_open(char * instrDescriptor, unsigned long * handle);
% __stdcall int usbtmc_write (unsigned long * handle, char *command, int timeout);
% __stdcall int usbtmc_read(unsigned long * handle, char *data, int timeout);
% __stdcall int usbtmc_close (unsigned long * handle);
%
% //Error codes for Admesy_usbtmc
% #define ERROR_NOLIB         -20     //NO Library found
% #define ERROR_NOLIB_OPEN    -21     //NO Library opened
% #define ERROR_LIBUSB_EMTSTR -22     //Vendorid or productid emty (only for LibUSB)
%
% //All other error codes are passed through
% //NI-VISA errors http://zone.ni.com/reference/en-XX/help/lv/71/lverror/VISA_Error_Codes/
% //Libusb errors http://libusb.sourceforge.net/api-1.0/group__misc.html
%
% #ifdef __cplusplus
% }
% #endif
%
% #endif // __ADMESY_USBTMC_h


% This function was generated by loadlibrary.m parser version 1.1.6.29 on Tue Oct 30 20:36:00 2012
% perl options:'admesy_usbtmc.i -outfile=admesy_usbtmc_matlab.m'

% initialization
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];
enuminfo=[];
fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival);
ThunkLibName=[];

% prototypes of functions included in admesy_usbtmc.dll

% int usbtmc_find_devices ( char * usbtmcdevices );
fcns.name{fcnNum}='usbtmc_find_devices';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'cstring'};
fcnNum=fcnNum+1;

% int usbtmc_open ( char * instrDescriptor , unsigned long * handle );
fcns.name{fcnNum}='usbtmc_open';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'cstring', 'ulongPtr'};fcnNum=fcnNum+1;

% int usbtmc_write ( unsigned long * handle , char * command , int timeout );
fcns.name{fcnNum}='usbtmc_write';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'ulongPtr', 'cstring', 'int32'};fcnNum=fcnNum+1;

% int usbtmc_read ( unsigned long * handle , char * data , int timeout );
fcns.name{fcnNum}='usbtmc_read';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'ulongPtr', 'cstring', 'int32'};fcnNum=fcnNum+1;

% int usbtmc_close ( unsigned long * handle );
fcns.name{fcnNum}='usbtmc_close';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'ulongPtr'};

methodinfo=fcns;

return
