function [methodinfo,structs,enuminfo,ThunkLibName]=crs_colorcal_matlab

% A MATLAB version of header file, CalibInterface.h
% function [methodinfo,structs,enuminfo,ThunkLibName]=crs_colorcal_matlab
%
% Created    : "2013-12-09 16:20:35 ban"
% Last Update: "2013-12-11 17:51:25 ban"
%
% [about]
% CRS_COLORCAL_MATLAB creates structures to define interfaces found in 'Calibrator.dll'.
% This is a MATLAB-based C-langurage prototype file required to use functions included in
% Calibrator.dll that controls Cambridge Research Systems ColorCAL Mark-2 from our own programs.
%
% [note]
% Generally, to load CalibInterface.h with its DLL using 'loadlibrary' function as
% >> loadlibrary('Calibrator.dll','CalibInterface.h','alias','Calibrator');
% will be fine. Of course, the header file 'Calibrator.dll' and 'CalibInterface.h' is correct
% when it is loaded in C/C++.
%
% However, the way Calibrator.dll exposes its functions seems to be not compatible with
% the calling convention that MATLAB expects (cdecl vs. stdcall). Thus, I modified
% CalibInterface.h so that it is compatible with MATLAB convention.
% Then, I output new crs_colorcal_matlab to a MATLAB-based C-language prototype file using
% >> loadlibrary('Calibrator.dll','CalibInterface.h','alias','Calibrator','mfilename','crs_colorcal_matlab');
%
% [an example of the original version of CalibInterface.h]
%
% (continued...)
% // Read a luminance value (in cd/m²) back from the device
% // To convert this to fL, divide by 3.426259101
% __declspec( dllimport ) _stdcall int calReadLuminance(double *Luminance);
% (continued...)
%
% [an example of the modified version of CalibInterface.h]
%
% (continued...)
% // Read a luminance value (in cd/m²) back from the device
% // To convert this to fL, divide by 3.426259101
% __declspec( dllimport ) _stdcall int calReadLuminance(double *Luminance);
% (continued...)

%This function was generated by loadlibrary.m parser version 1.1.6.29 on Mon Dec  9 16:06:09 2013
%perl options:'CalibInterface.i -outfile=crs_colorcal_matlab.m'

% initialization
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];
enuminfo=[];
fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival);
ThunkLibName=[];

% ******************************************************************************
% interfaces to functions in Calibrator.dll
% ******************************************************************************

% _stdcall int calInitialise ( int Device ); 
fcns.name{fcnNum}='calInitialise';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'int32'};
fcnNum=fcnNum+1;

% _stdcall int calReadLuminance ( double * Luminance ); 
fcns.name{fcnNum}='calReadLuminance';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'doublePtr'};
fcnNum=fcnNum+1;

% _stdcall int calReadVoltage ( double * Voltage ); 
fcns.name{fcnNum}='calReadVoltage';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'doublePtr'};
fcnNum=fcnNum+1;

% _stdcall int calReadColour ( double * CieX , double * CieY , double * CieLum ); 
fcns.name{fcnNum}='calReadColour';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'doublePtr'};
fcnNum=fcnNum+1;

% _stdcall int calCloseDevice ( void ); 
fcns.name{fcnNum}='calCloseDevice';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}=[];
fcnNum=fcnNum+1;

% _stdcall int calAutoCalibrate ( void ); 
fcns.name{fcnNum}='calAutoCalibrate';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}=[];
fcnNum=fcnNum+1;

% ***************************   ADVANCED FUNCTIONS   ***************************
% ************ Do not use these.  The four functions above should be ***********
% ************     sufficient for simple optical applications        ***********
% ******************************************************************************

% _stdcall int calOpenDevice ( int DeviceType ); 
fcns.name{fcnNum}='calOpenDevice';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'int32'};
fcnNum=fcnNum+1;

% _stdcall int calSetMode ( char Mode ); 
fcns.name{fcnNum}='calSetMode';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'int8'};
fcnNum=fcnNum+1;

% _stdcall int calReadDeviceParams ( calDeviceConfigurationParams * Params ); 
fcns.name{fcnNum}='calReadDeviceParams';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'calDeviceConfigurationParamsPtr'};
fcnNum=fcnNum+1;

% _stdcall int calReadADCValue ( long * Value ); 
fcns.name{fcnNum}='calReadADCValue';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'longPtr'};
fcnNum=fcnNum+1;

% _stdcall int calWriteDeviceParams ( int AccessMode , int ParameterToWrite , calDeviceConfigurationParams * Params ); 
fcns.name{fcnNum}='calWriteDeviceParams';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'int32', 'int32', 'calDeviceConfigurationParamsPtr'};
fcnNum=fcnNum+1;

% _stdcall int calGetCapabilities ( calDeviceCapabilities * DC ); 
fcns.name{fcnNum}='calGetCapabilities';
fcns.calltype{fcnNum}='stdcall';
fcns.LHS{fcnNum}='int32';
fcns.RHS{fcnNum}={'calDeviceCapabilitiesPtr'};
fcnNum=fcnNum+1;

% ******************************************************************************
% prototypes (#define)
% ******************************************************************************

structs.calOptiCALSpecificParameters.members=struct('RefVoltage', 'long', 'ZeroError', 'long', 'FeedbackRes', 'long', 'VGainRes', 'long', 'ProbeSN', 'int8#128', 'ProbeCal', 'long');
structs.calColorCALSpecificParameters.members=struct('IntegrationTime', 'double', 'CompensationMatrix', 'double#9');
structs.calDeviceConfigurationParams.members=struct('DeviceType', 'long', 'DeviceVersion', 'long', 'SerialNumber', 'long', 'FirmwareVers', 'long', 'OptiCALParams', 'calOptiCALSpecificParameters', 'ColorCALParams', 'calColorCALSpecificParameters');
structs.calDeviceCapabilities.members=struct('Size', 'int32', 'CapabilityFlags', 'int32', 'MinSampleTime', 'int32');

methodinfo=fcns;
