function powel_hybrid_estimate=AutoColorEstimatePowellHybrid(rawxyY,myxyY,phosphers,flare_XYZ,lut,colorimeterhandler,displayhandler,options)

% function powel_hybrid_estimate=AutoColorEstimatePowellHybrid(rawxyY,myxyY,phosphers,flare_XYZ,lut,colorimeterhandler,displayhandler,options)
%
% Estimate [R,G,B] values to produce CIE 1931 xyY values you want to display.
% Estimation is done based on both
% 1. least-square estimation assuming piecewise linearity, and
% 2. Brent-Powell with Coggins/Golden-section linear search optimization
%
% [input]
% rawxyY             : raw xyY you want, [3 x n] matrix
% myxyY              : your xyY after preprocessing (e.g. flare-correction), [3 x n] matrix
%                      if no preprocessing is applied, myxyY=rawxyY;
% phosphers          : phospher xyY, [rx,gx,bx;ry,gy,by;rY,gY,bY] after preprocessing
% flare_XYZ          : flare XYZ, [X,Y,Z] !NOTE! not used now May 16 2012 Hiroshi Ban
% lut                : color lookup table, [n x 3(r,g,b)] matrix, set lut=[]; if you do not need to use LUTs
% colorimeterhandler : handle to an object to manipulate colorimeter
% displayhandler     : function handle to manipulate/display color window
% options            : options, structure with the parameters below
%                      lin.iteration --- the number of iterations of estimation
%                      lin.samples   --- the number of samples to estimate local tristimulus values (XYZ)
%                      lin.rmserror  --- rsm error threshold to stop the estimation
%                      lin.ss0       --- search space to estimate the local tristimulus values, from ss0-ss1
%                      lin.ss1
%                      + options.powell, structure generated by optimset function
%                      e.g. options.nonlin=optimset('Display','off','TolX',1e-2);
%                      for details, see fminpowell.m in iFit toolbox
%
% [output]
% powel_hybrid_estimate    : cell structure {n x 1}, holding the estimation results with the variables below
%                      .method --- 'LUT' or 'RGB
%                      .wanted_xyY
%                      .measured_xyY
%                      .residuals --- measured_xyY minus rawxyY
%                      .rms --- error
%                      .RGB --- RGB values for all the estimations
%                      .LUT --- lut index if .method='LUT'
%                      .final_xyY --- the final estimation of xyY
%                      .final_RGB --- the final estimation of RGB
%                      .final_LUT --- the final estimation of LUT
%
%
% Created    : "2012-05-30 20:15:22 ban"
% Last Update: "2012-05-30 20:36:56 ban"

% check input variables
if nargin<7, help(mfilename()); powel_hybrid_estimate=[]; return; end

if nargin<8 || isempty(options)
  options.lin.iteration=3;
  options.lin.samples=18;
  options.lin.rmserror=1; % percent error
  options.lin.ss0=2.0; % search space, from ss0 to ss1
  options.lin.ss1=1.0;
  options.powell=optimset(); % empty structure
  options.powell.Display='iter';
  options.powell.TolFun =1e-3;
  options.powell.TolX   =1e-3;
  options.powell.MaxIter=80;
  options.powell.MaxFunEvals=100;
  options.powell.Hybrid = 'Coggins';
  options.powell.algorithm  = 'Powell Search (by Secchi) [ fminpowell ]';
  options.powell.optimizer = 'fminpowell';
end

if ~isstructmember(options,'lin'), options.lin=struct(); end
if ~isstructmember(options.lin,'iteration'), options.lin.iteration=3; end
if ~isstructmember(options.lin,'samples'), options.lin.samples=18; end
if ~isstructmember(options.lin,'rmserror'), options.lin.rmserror=1; end
if ~isstructmember(options.lin,'ss0'), options.lin.ss0=2.0; end
if ~isstructmember(options.lin,'ss1'), options.lin.ss1=1.0; end
if ~isstructmember(options,'powell'), options.powell=optimset(); end
if ~isstructmember(options.powell,'Display'), options.powell.Display='iter'; end
if ~isstructmember(options.powell,'TolFun'), options.powell.TolFun=1e-3; end
if ~isstructmember(options.powell,'TolX'), options.powell.TolX=1e-3; end
if ~isstructmember(options.powell,'MaxIter'), options.powell.MaxIter=50; end
if ~isstructmember(options.powell,'MaxFunEvals'), options.powell.MaxFunEvals=200; end
if ~isstructmember(options.powell,'Hybrid'), options.powell.Hybrid='Coggins'; end
if ~isstructmember(options.powell,'algorithm'), options.powell.algorithm='Powell Search (by Secchi) [ fminpowell ]'; end
if ~isstructmember(options.powell,'optimizer'), options.powell.optimizer='fminpowell'; end

% set constrains
constrains.min=zeros(1,3);
constrains.max=ones(1,3);
constrains.fixed=zeros(1,3);
constrains.steps=0.1;

% to store measured value
mxyY=zeros(3,options.lin.iteration);

% to store local XYZ/RGB data samples to estimate a new transformation
% matrix by least squares, assuming piecewise linearity
sXYZ=zeros(3,options.lin.samples);
sRGB=zeros(3,options.lin.samples);
msXYZ=zeros(3,options.lin.samples);

% output variable to store the results
linear_estimate=cell(size(myxyY,2),1);
powel_hybrid_estimate=cell(size(myxyY,2),1);

% initialize color window
fig_id=displayhandler([255,255,255],1); pause(0.2);

%% least-square estimations of RGB values
for mm=1:1:size(myxyY,2)

  % ===== LINEAR ESTIMATION =====

  % initial transformation
  pXYZ0=xyY2XYZ(phosphers); % set the global phospher XYZ matrix as initial values
  T0=inv(pXYZ0);

  % estimation of the transformation matrix
  % here, estimation is done in XYZ space, not in xyY, to make the estimation stable.
  % if we estimate in xyY space, the results will be distorted as Y is too large compared with the other values
  for ii=1:1:options.lin.iteration

    % the first estimation of RGB values
    RGB0=T0*xyY2XYZ(myxyY(:,mm)); RGB0(RGB0<0)=0; RGB0(RGB0>1)=1;
    if ~isempty(lut), RGB0=getRGBfromLUT(lut,RGB0); end

    % Measuring CIE1931 xyY
    [YY,xx,yy,displayhandler,colorimeterhandler]=...
      MeasureCIE1931xyY(displayhandler,colorimeterhandler,RGB0,1,fig_id);

    % calculate error
    xyY0=[xx;yy;YY];
    XYZ0=xyY2XYZ(xyY0);
    eXYZ=abs(XYZ0-xyY2XYZ(rawxyY(:,mm))); % erorr in XYZ space

    % generate samples & measure
    ss=options.lin.ss0+(ii-1)*(options.lin.ss1-options.lin.ss0)/(options.lin.iteration-1);

    % get samples to estimate a new transformation matrix (local phospher xyY),
    % assuming a piecewise linearity
    for rr=1:1:options.lin.samples

      % generate local RGB data set
      sXYZ(:,rr)=xyY2XYZ(myxyY(:,mm))+unifrnd(-ss*eXYZ,ss*eXYZ);
      tmp=T0*sXYZ(:,rr); tmp(tmp<0)=0; tmp(tmp>1)=1;
      sRGB(:,rr)=tmp;
      if ~isempty(lut)
        RGB1=getRGBfromLUT(lut,sRGB(:,rr));
      else
        RGB1=sRGB(:,rr);
      end

      % Measuring CIE1931 xyY
      [YY,xx,yy,displayhandler,colorimeterhandler]=...
        MeasureCIE1931xyY(displayhandler,colorimeterhandler,RGB1,1,fig_id);

      sxyY=[xx;yy;YY];
      %msXYZ(:,rr)=xyY2XYZ(sxyY)-flare_XYZ;
      msXYZ(:,rr)=xyY2XYZ(sxyY);

    end % for rr=1:1:options.lin.samples

    % estimate transformation from local samples acquired above by least-squares
    % MODEL: RGB' = XYZ'*T
    %        RGB = T'*XYZ
    % SOLUTION: T = inv(xXYZ*sXYZ')*sXYZ*sRGB'
    %T1=inv(msXYZ*msXYZ')*msXYZ*sRGB';
    T1=(msXYZ*msXYZ')\msXYZ*sRGB';
    T1=T1';

    % generate local phospher RGB
    RGB2=T1*xyY2XYZ(myxyY(:,mm)); RGB2(RGB2<0)=0; RGB2(RGB2>1)=1;
    if ~isempty(lut), RGB2=getRGBfromLUT(lut,RGB2); end

    % Measuring CIE1931 xyY
    [YY,xx,yy,displayhandler,colorimeterhandler]=...
      MeasureCIE1931xyY(displayhandler,colorimeterhandler,RGB2,1,fig_id);

    % update the transformation matrix
    xyY1=[xx;yy;YY];
    mxyY(:,ii)=xyY1;
    T0=T1;

    % calculate RMS error
    e=(xyY1-rawxyY(:,mm))./rawxyY(:,mm)*100; % [%] error
    %e=(xyY2XYZ(xyY1)-xyY2XYZ(rawxyY(:,mm)))./xyY2XYZ(rawxyY(:,mm))*100; % [%] error
    rms=sqrt(e'*e);

    % store the data
    linear_estimate{mm}.rms(ii)=rms;
    linear_estimate{mm}.RGB(:,ii)=RGB2;

    % break if rmserror reaches the criteria
    if rms<options.lin.rmserror, break; end

  end % for ii=1:1:options.lin.iteration

  [dummy,idx]=min(linear_estimate{mm}.rms);
  RGB0=linear_estimate{mm}.RGB(:,idx);

  % convert the estimated RGB value to RGB ratio
  for nn=1:1:3
    [dummy,idx]=min(abs(lut(:,nn)-RGB0(nn)));
    RGB0(nn)=idx./size(lut(:,nn),1);
  end
  RGB0(RGB0<0)=0; RGB0(RGB0>1)=1;

  % ===== ESTIMATION USING BLENT-POWELL WITH COGGINS/GOLDEN-SECTION METHOD =====

  % Measuring & optimizing CIE1931 xyY
  RGB=fminpowell(@estimate_xyY,RGB0,options.powell,constrains,rawxyY(:,mm),displayhandler,colorimeterhandler,lut,fig_id);
  if ~isempty(lut), RGB=getRGBfromLUT(lut,RGB); end

  % check the accuracy of xyY for the optimized RGB values
  [YY,xx,yy,displayhandler,colorimeterhandler]=...
    MeasureCIE1931xyY(displayhandler,colorimeterhandler,RGB,1,fig_id);

  mxyY=[xx;yy;YY];

  % calculate RMS error
  e=(mxyY-rawxyY(:,mm))./rawxyY(:,mm)*100; % [%] error
  rms=sqrt(e'*e);

  % store the data
  if ~isempty(lut)
    powel_hybrid_estimate{mm}.method='LUT';
  else
    powel_hybrid_estimate{mm}.method='RGB';
  end
  powel_hybrid_estimate{mm}.wanted_xyY=rawxyY(:,mm);
  powel_hybrid_estimate{mm}.measured_xyY=mxyY;
  powel_hybrid_estimate{mm}.residuals=mxyY-rawxyY(:,mm);
  powel_hybrid_estimate{mm}.rms=rms;
  powel_hybrid_estimate{mm}.RGB=RGB;
  if ~isempty(lut)
    for nn=1:1:3
      [dummy,idx]=min(abs(lut(:,nn)-RGB(nn)));
      powel_hybrid_estimate{mm}.LUT(nn)=idx;
    end
  end
  powel_hybrid_estimate{mm}.final_xyY=powel_hybrid_estimate{mm}.measured_xyY;
  powel_hybrid_estimate{mm}.final_RGB=powel_hybrid_estimate{mm}.RGB;
  if ~isempty(lut), powel_hybrid_estimate{mm}.final_LUT=powel_hybrid_estimate{mm}.LUT; end

end % for mm=1:1:size(myxyY,1)

displayhandler(-999,1,fig_id);

return


% subfunction to do non-linear optimization
function sse=estimate_xyY(params,wanted_xyY,displayhandler,colorimeterhandler,lut,fig_id)

% estimates CIE1931 xyY using a given transformation matrix
% params=[r;b;g]; or params=[lutRidx,lutGidx,lutBidx];

% set variable
RGB=params;
RGB(RGB>1)=1.0; RGB(RGB<0)=0.0;
if ~isempty(lut), RGB=getRGBfromLUT(lut,RGB); end

% measure CIE1931 xyY
[YY,xx,yy,displayhandler,colorimeterhandler]=...
  MeasureCIE1931xyY(displayhandler,colorimeterhandler,RGB,1,fig_id);

% calculate error
cxyY=[xx;yy;YY];

%% note: Though the error calculation here looks strange, I mean this fine.
%%       This is to match the criteria of error with linear transformation.
%%       If you want to calc the correct SSE, please use the first 2 lines.
%eXYZ=xyY2XYZ(cxyY)-xyY2XYZ(wanted_xyY);
%sse=eXYZ'*eXYZ;
exyY=(cxyY-wanted_xyY)./wanted_xyY.*100;
sse=sqrt(exyY'*exyY);

return


% subfunction to get RGB value from LUT
function [rgb,lutidx]=getRGBfromLUT(lut,rgb)

lutidx=ceil(rgb.*size(lut,1));
lutidx(lutidx<=0)=1;
lutidx(lutidx>size(lut,1))=size(lut,1);
for nn=1:1:3, rgb(nn)=lut(lutidx(nn),nn); end

return
