<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="c:/cygwin/home/ban/.pandoc/github-pandoc.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="readme-on-mcalibrator2"><strong>README on Mcalibrator2</strong></h1>
<div>Created    : "2013-05-13 12:30:52 ban"</div>
<div>
<p>Last Update: &quot;2018-02-02 12:52:07 ban&quot;</p>
<hr />
<h1 id="menu"><a name = "Menu"> <strong>Menu</strong> </a></h1>
<ul>
<li><a href="#Introduction">Introduction what is Mcalibrator2 ?</a></li>
<li><a href="#System">System requirements</a></li>
<li><a href="#Launch">How to launch Mcalibrator2</a></li>
<li><a href="#Help">How to generate/update html-based Mcalibrator2 help files</a></li>
<li><a href="#Manual">Detailed manual of Mcalibrator2</a></li>
<li><a href="#Purposes">Aims and purposes</a></li>
<li><a href="#Installation">Installation</a></li>
<li><a href="#Configuration">Mcalibrator2 configuration - setting measurement/calibration parameters</a></li>
<li><a href="#Measure">Measure tab (you can measure CIE1931 xyY here)</a></li>
<li><a href="#LUT">LUT tab - Running Gamma-correction and generating Color-LookUp tables (CLUTs)</a></li>
<li><a href="#Chromaticity">Chromaticity (CIE1931 xyY etc) estimation procedure</a></li>
<li><a href="#About">About tab</a></li>
<li><a href="#CustomColorimeter">How to make Mcalibrator2 communicate with your own colorimeter(s) or photometer(s)</a></li>
<li><a href="#CustomEstimation">How to add your own chromaticity estimation methods to Mcalibrator2</a></li>
<li><a href="#Scripting">Automations and scripting of Mcalibrator2</a></li>
<li><a href="#Acknowledgments">Acknowledgments</a></li>
<li><a href="#License">License</a></li>
<li><a href="#Citations">Citations</a></li>
<li><a href="#TODO">TODO</a></li>
</ul>
<hr />
<h1 id="introduction-what-is-mcalibrator2"><a name = "Introduction"> <strong>Introduction what is Mcalibrator2 ?</strong> </a></h1>
<p><img src="doc/imgs/00_mc_about.png" alt="Mcalibrator2" /> <img src="doc/imgs/00_mc_select.png" alt="Mcalibrator2" /></p>
<p>Mcalibrator2 is a <strong><em>MATLAB</em></strong>-based GUI display luminance and chromaticity characterization software package for visual neuroscience and psychology studies. The package is especially focusing on</p>
<ol>
<li>providing accurate gamma-correction, and<br />
</li>
<li>finding the best RGB video inputs to produce the required CIE1931 xyY values using several goal-seeking optimization algorithms.</li>
</ol>
<p>(Matlab is a registered trademark of <a href="https://www.mathworks.com/"><strong><em>The Mathworks Inc.</em></strong></a> )</p>
<p>For details, please read documents in <em>~/Mcalibrator2/doc</em> directory.<br />
Also please see the link below.</p>
<ul>
<li><a href="http://www.cv.jinkan.kyoto-u.ac.jp/site/mcalibrator/"><strong>Mcalibrator2 original website</strong></a></li>
<li><a href="https://github.com/hiroshiban/Mcalibrator2"><strong>Mcalibrator2 GitHub repository</strong></a></li>
</ul>
<p>The details of the algorithms we developed are described below.</p>
<ul>
<li><a href="http://www.journalofvision.org/content/13/6/20.long"><strong>Original paper published in Journal of Vision, 2013</strong></a></li>
</ul>
<p>Thank you for using our software.<br />
We are happy if Mcalibrator2 can help your research projects.</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="system-requirements"><a name = "System"> <strong>System requirements</strong> </a></h1>
<ul>
<li><strong>OS: Windows XP/VISTA/7/8/10 or Mac OSX</strong></li>
<li>note 1: Windows OS is required to use some photometers with Mcalibrator2 as only Windows drivers are distributed for them.</li>
<li>note 2: On a Mac OSX box, an interface to a virtual serial port is required (generally implemented by default).</li>
<li><p>note 3: We have not tested Mcalibrator2 on any Linux boxes. But it would work once you can get a proper serial or usb interface with a valid driver to control your photometer.</p></li>
<li><strong>MATLAB R2009a</strong> or later (We have tested the latest version with <strong>R2014b</strong> and <strong>R2017a</strong>), and &quot;Optimization&quot; and &quot;Statistics&quot; toolboxes</li>
<li>note 1: Mcalibrator2 works even without optimization/statistics toolboxes, but to use full functionality of the software (e.g. automatic non-linear RGB video input estimations), these toolboxes are required.</li>
<li><p>note 2: Mcalibrator2 can not be launched properly on MATLAB R2007 or older since the GUI handling system that we are using to control Mcalibrator2 windows is quite different from the conventions of the older MATLABs.</p></li>
</ul>
<p><a href="#Menu">return to menu</a></p>
<h1 id="how-to-launch-mcalibrator2"><a name = "Launch"> <strong>How to launch Mcalibrator2</strong> </a></h1>
<p>To launch Mcalibrator on MATLAB, please run</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">&gt;&gt; Mcalibrator2</code></pre></div>
<p>Please note that when you use MATLAB version 2012 or later, a function to control GUI tabs, &quot;tabselectionfcn&quot;, will be disabled due to incompatibility of the function with the recent MATLAB.</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="how-to-generateupdate-html-based-mcalibrator2-help-files"><a name = "Help"> <strong>How to generate/update html-based Mcalibrator2 help files</strong> </a></h1>
<p>Please run</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">&gt;&gt; update_Mcalibrator2_html_docs</code></pre></div>
<p>Then, all the html-based help documents will be automatically generated in <strong>~/Mcalibrator2/doc/html</strong>.<br />
To read the help documents, please open <strong>~/Mcalibrator2/doc/html/index.html</strong> on your browser.</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="detailed-manual-of-mcalibrator2"><a name = "Manual"> <strong>Detailed manual of Mcalibrator2</strong> </a></h1>
<h1 id="aims-and-purposes"><a name = "Purposes"> Aims and purposes </a></h1>
<p>Display characterization is an essential part of the experimental procedures in vision science because almost all current experiments are conducted in computer-aided environments: visual stimuli are manipulated via a programming language and displayed on a computer display, and observer's responses are acquired by pressing keys connected to a computer. To ensure that visual stimuli - their luminance, color, timing, etc. are presented precisely in such computer-based experiments, researchers need to characterize display devices accurately in advance of actual experiments.</p>
<p>CRT (Cathode Ray-Tube) displays are the most widely-used devices for current vision experiments, and the calibration procedures to characterize their luminance and chromaticities are well-established in the two-stage procedures: gamma-correction, followed by a linear color transformation (Berns et al., 1996; Brainard et al., 2002; Ban et al., 2006). The calibration results obtained through this standard two-step procedure has been tested (Brainard et al., 2002; Ban et al., 2006) and the quality of luminance and chromatic stimuli on CRT displays satisfy the researchers' criterion.</p>
<p>However, non-CRT devices such as a LCD (Liquid Crystal Display) and a DLP (Digital Light Processing) have come into the main stream recently and researchers are required to use non-CRT over CRT devices. There is no evidence that the standard display characterization method cannot be applied to these new types of devices since the current widely-used standard display calibration method is established based on the internal model of CRT devices.</p>
<p>We have therefore developed a non-device-specific approach to display characterization. Specifically, our new methods use model-free gamma-correction procedure combined with a linear/non-linear (Nelder-Mead Simplex, Nelder &amp; Mead, 1965; Dennis &amp; Woods, 1987) hybrid or line search (Powell's method with Coggins constrain, Powell, 1964; Brent, 1973; Press et al., 2007; Farhi, 2011; Farhi et al, 2012) algorithm to get the optimal RGB video input values to produce the required luminance and chromaticities. The methods only assume 1) a monotonic increment of luminance against the increment of video input values, and 2) a piece wise linearity of the system in the initial estimation step. These new methods have a much broader range of applicability because they do not presume the internal model of the display device and can handle non-linearity of the device.</p>
<p>The whole procedures are integrated into a GUI-based display characterization software written in MATLAB (The Mathworks, Inc, USA) language and termed &quot;Mcalibrator2&quot; (Ban &amp; Yamamoto, 2013). The applicability and efficiency of our software to a wide range of display devices, including LCD and DLP type of devices, were confirmed by comparing the calibration accuracies of our procedures with that of the standard two-stage method. We found that all of these new approaches improved calibration accuracies for non-CRT devices compared with the standard display characterization procedure.<br />
Mcalibrator2 has provided some additional components to communicate with any photometers that researchers are using in their daily measurements. The software has also provided simple frameworks to add alternative chromaticity optimization procedures researchers may want to use. Further, the software can automatically generate gamma-correction tables compatible with Psychtoolbox, one of the most widely used vision science tools (Brainard, 1997; Pelli, 1997). These functions will assist researchers in characterizing their display devices.</p>
<p>The authors provide this software suite in the hope that it will benefit researchers performing calibration of their display devices efficiently and improve accuracies of stimulus displays regardless of the display types.</p>
<p><img src="doc/imgs/00_Schematic_illustration_of_chromaticity_estimations.png" alt="Mcalibrator2 schematic illustrations of chromaticity estimation procedures" /><br />
<strong>Schematic illustrations of the Gamma-correction and chromaticity estimation procedures implemented in Mcalibrator2.</strong></p>
<p>a) Standard Gamma-correction procedures. b) Standard linear chromaticity estimation procedure. c) Custom Gamma-correction procedures. d) Custom chromaticity estimation procedures based on goal-seeking optimization algorithms</p>
<p><strong><em>References</em></strong></p>
<ol>
<li>Ban, H., Yamamoto, H., Ejima, Y. (2006). Mcalibrator: MATLAB integrated GUI software for display calibration a proposal of a new color calibration procedure applicable to a wide range of display devices and evaluation of its efficiency . The Japanese Journal of Psychonomic Science. 24(2). 149-161.</li>
<li>Ban, H., &amp; Yamamoto, H. (2013). A non-device-specific approach to display characterization based on linear, nonlinear, and hybrid search algorithms. Journal of Vision, 13(6):20, 1-26.</li>
<li>Berns, R.S. (1996). Methods for Characterizing CRT Displays. Displays. 16, 173-182.</li>
<li>Brainard, D.H. (1997). The psychophysics toolbox. Spatial Vision. 10, 433-436.</li>
<li>Brainard, D.H., Pelli, D.G., Robson, T. (2002). Display Characterization. Encyclopedia of Imaging Science and Technology. Wiley, 172-188</li>
<li>Brent, R.P. (1973). Section 7.3: Powell's algorithm. In Algorithms for minimization without derivatives. Englewood Cliffs, N.J.: Prentice-Hall.</li>
<li>Dennis, J.E.Jr., Woods, D.J. (1987). New Computing Environments: Microcomputers in Large-Scale Computing. Edited by A. Wouk, SIAM, 116-122.</li>
<li>Farhi, E. (2011). The iFit data analysis library, ILL, Computing for Science. Online reference: *<a href="http://ifit.mccode.org*" class="uri">http://ifit.mccode.org*</a></li>
<li>Farhi, E., Debab, Y., Willendrup, P. (in press). Journal of Neutron Research.</li>
<li>Nelder, J.A., Mead, R. (1965). A Simplex Method for Function Minimization. Computer Journal, 7, 308-313.</li>
<li>Pelli, D.G. (1997). The video toolbox software for visual psychophysics: transforming numbers into movies. Spatial Vision. 10, 437-442.</li>
<li>Powell, M. J. D. (1964). An efficient method for finding the minimum of a function of several variables without calculating derivatives. Computer Journal 7 (2): 155-162.</li>
<li>Press, W.H., Teukolsky, S.A., Vetterling, W.T., Flannery, B.P. (2007). Section 9.3. Van Wijngaarden Dekker Brent Method. Numerical Recipes: The Art of Scientific Computing (3rd ed.). New York: Cambridge University Press.</li>
</ol>
<p><a href="#Menu">return to menu</a></p>
<h1 id="installation"><a name = "Instllation"> Installation </a></h1>
<ol>
<li>You need to install <strong>MATLAB</strong> (<a href="https://www.mathworks.com/"><strong><em>The Mathworks Inc.</em></strong></a>) to use Mcalibrator2.<br />
You may additionally need to install <strong>&quot;Optimization&quot;</strong> and <strong>&quot;Statistics&quot;</strong> toolboxes to use all the functions of Mcalibrator2.</li>
<li><p>Please get the latest version of Mcalibrator2 from the link below,<br />
<a href="https://github.com/hiroshiban/Mcalibrator2"><strong>Mcalibrator2 GitHub repository</strong></a><br />
and add the <em>~/Mcalibrator2</em> directory to your MATLAB-path. If you use a MATLAB after 2011a, you do not need to add subdirectories.<br />
Mcalibrator2 can handle all the subrouines internally.<br />
If you use MATLAB before 2011a, please set MATLAB-path to the Mcalibrator2 including all the subdirectories.</p></li>
<li><p>Please launch Mcalibrator2 from the MATLAB console,</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">&gt;&gt; Mcalibrator2</code></pre></div>
<p>Then, you will see the main window of Mcalibrator2 as below.</p></li>
</ol>
<p><a href="#Menu">return to menu</a></p>
<h1 id="mcalibrator2-configuration---setting-measurementcalibration-parameters"><a name = "Configuration"> Mcalibrator2 configuration - setting measurement/calibration parameters </a></h1>
<p><img src="doc/imgs/01_config_tab.png" alt="Mcalibrator2 config tab" /><br />
<strong>Mcalibrator2: config tab</strong></p>
<p>The &quot;config&quot; tab above is for setting measurement/calibration parameters.</p>
<ol>
<li>You can set all the measurement/calibration parameters in this tab.<br />
The details of the configuration parameters are described on the &quot;Info&quot; window.<br />
After setting all the parameters, please press &quot;OK&quot; button.<br />
Then, all the parameters are saved and &quot;measure&quot;, &quot;LUT&quot;, &quot;Color Calculator&quot; tabs will be ready to be used.</li>
<li>If you press &quot;Save config&quot; button, the current parameters will be saved under <strong><em>~/Mcalibrator2/config</em></strong> directory.<br />
Yuo can load those parameters anytime with pressing &quot;Load config&quot; button.</li>
<li>On the <strong>[date]</strong> editing window, you can set the data name as you like such as <em>yymmdd_1</em>, <em>yymmdd_2</em>, or <em>yymmdd_display1</em>, as well as <em>yymmdd</em> format.<br />
When you need to calibrate a display device twice or more in a day, please change [date] names so that they are not overlapped.</li>
<li>When you set a previous date on the <strong>[date]</strong> window, and if the corresponding data directory exists in <strong><em>~/Mcalibrator2/data</em></strong>, you can load those previous data on memory.</li>
</ol>
<p>Next, you can proceed to measure RGB phosphor luminance values. Please go to &quot;measure&quot; tab.</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="measure-tab-you-can-measure-cie1931-xyy-here"><a name = "Measure"> Measure tab (you can measure CIE1931 xyY here) </a></h1>
<p><img src="doc/imgs/02_measure_tab.png" alt="Mcalibrator2 measure tab" /><br />
<strong>Mcalibrator2: measure tab</strong></p>
<p>You can set up a photometer and measure luminance values on this <strong><em>&quot;measure&quot;</em></strong> tab.</p>
<p>First, please press &quot;Adjust Colorimeter Position&quot; button. Then, the grid window will be displayed on the screen. You can adjust and set a colorimeter focus using this window. The colorimeter position can be adjusted and validated anytime when you press the <strong><em>&quot;Adjust Colorimeter Position&quot;</em></strong> button.</p>
<p><img src="doc/imgs/03_adjust_window.png" alt="Mcalibrator2 measurement position adjustment" /><br />
<strong>Mcalibrator2: adjustment of your colorimeter position</strong></p>
<p>Next, set an ID of the serial (or USB) port to which your colorimeter is connected. On Windows, the ID will be like <strong><em>COM1</em></strong>, <strong><em>COM2</em></strong>, ..., on Linux, it will be like <strong><em>/dev/ttyS0</em></strong>, and on Mac, it will be like <strong><em>/dev/tty.KeySerial1</em></strong>.<br />
(<strong><em>Please note that the authors have mainly tested Mcalibrator2 on Windows PC. We have not tested the software on Mac or Linux machines. Sorry</em></strong>.)<br />
After setting the ID, please press <strong><em>&quot;Create&quot;</em></strong> button, and a serial (or USB) object to communicate with the colorimeter will be generated. Then, by pressing <strong><em>&quot;Initialize Apparatus&quot;</em></strong> button, the colorimeter will be initialized through the port.</p>
<p>The initial setups finished now. If you press <strong><em>&quot;Measure CIE1931 xyY&quot;</em></strong> button, the luminance values are measured against 32 (by default) video inputs for each of the RGB phosphors.</p>
<p>After completing the measurements, the relationship between video input and luminance output values will be plotted as below.</p>
<p><img src="doc/imgs/04_measure_tab_after_measurements.png" alt="Mcalibrator2 measure tab after measurements" /><br />
<strong>Mcalibrator2: measure tab after measurements</strong></p>
<p>The whole procedure on &quot;measure&quot; tab is completed now.<br />
Next, Mcalibrator2 is going to generate Color Lookup Tables (CLUTs) by linearizing the input/output relationship. Please go to <strong><em>&quot;LUT&quot;</em></strong> tab.</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="lut-tab---running-gamma-correction-and-generating-color-lookup-tables-cluts"><a name = "LUT"> LUT tab - Running Gamma-correction and generating Color-LookUp tables (CLUTs) </a></h1>
<p><img src="doc/imgs/05_LUT_tab.png" alt="Mcalibrator2 LUT tab" /><br />
<strong>Mcalibrator2: LUT tab (performing gamma-correction and generating CLUTs)</strong></p>
<ol>
<li>Please select a fitting model to describe the input/output relationship.
<ul>
<li>When you are using CRTs, <strong><em>&quot;Gain-Offset-Gamma&quot;</em></strong> (a well-known standard gamma-correction model) is recommended.</li>
<li>When you are using a LCD or DLP, <strong><em>&quot;cubic spline&quot;</em></strong> or <strong><em>&quot;robust cubic spline&quot;</em></strong> is recommended.<br />
</li>
<li>If you select <strong><em>&quot;grid search&quot;</em></strong> , LUTs are generated by directly searching the best values,<br />
but it will only work when you measure all 256 points (when you set #LUT step to 256 on an 8-bit phosphor).</li>
</ul></li>
</ol>
<p><img src="doc/imgs/05_LUT_tab_model_selection.png" alt="Mcalibrator2 LUT tab model selection" /><br />
<strong>Mcalibrator2: Selecting a model for a gamma-correction</strong></p>
<ol>
<li>Please press <strong><em>&quot;Fit a model&quot;</em></strong> button, the selected model is fitted to the data and the results will be displayed on the <strong><em>&quot;measure&quot;</em></strong> tab.</li>
</ol>
<p><img src="doc/imgs/06_measure_tab_after_gamma_correction.png" alt="Mcalibrator2 measure tab after the gamma correction" /><br />
<strong>Mcalibrator2: Gamma-correction results</strong></p>
<ol>
<li>If the fitting results are fine, please press <strong><em>&quot;Create Color Lookup Table&quot;</em></strong> button.<br />
CLUTs will be generated and saved to <strong><em>~/Mcalibrator2/data/(date etc)</em></strong> .</li>
<li>The details of the measurements and the model fits (input/output relationship before/after gamma-corrections, LUTs, residuals of the fits etc.) will be plotted on the external figure windows. If you are running Mcalibrator2 on Windows in which <strong><em>Microsoft(C) PowerPoint</em></strong> is installed, these plots are saved into a PowerPoint slide file and stored to <strong><em>~/Mcalibrator2/data/(date etc.)</em></strong> automatically.</li>
<li>You can repeat LUT-generation procedure by changing a fitting model until you can get the best results.</li>
</ol>
<p><img src="doc/imgs/07_LUT_tab_after_generating_CLUTs.png" alt="Mcalibrator2 LUT tab after generating CLUTs" /><br />
<strong>Mcalibrator2: LUT tab after generating CLUTs</strong></p>
<p><img src="doc/imgs/08_model_fit_result.png" alt="Mcalibrator2 model fit result" /><br />
<strong>Mcalibrator2: Model fit result</strong></p>
<ol>
<li>To check how properly the Gamma-correction is performed, please press the <strong><em>&quot;Check the linearity&quot;</em></strong> button. When the <strong><em>&quot;easy check&quot;</em></strong> toggle button is ON (default), the generated CLUTs will be simply displayed on LUT tab. If it is set to OFF, luminance values for 20 video inputs (equally sampled from 0.0 to 1.0) are re-measured, and the linearity between the input video values and the output luminance are evaluated. If the results are not good, please re-generate CLUTs by changing a fitting model.</li>
</ol>
<p><img src="doc/imgs/09_LUT_tab_linearity_test.png" alt="Mcalibrator2 linearity test" /><br />
<strong>Mcalibrator2: Linearity test (Easy-check mode)</strong></p>
<p><img src="doc/imgs/10_LUT_tab_linearity_test_remeasured.png" alt="Mcalibrator2 linearity test" /><br />
<strong>Mcalibrator2: Linearity test (Remeasuring mode)</strong></p>
<p>The whole procedures of gamma-correction and CLUT generations are completed. If you do not need to get optimal RBG video inputs to produce the specific chromaticities (CIE1931 xyY, not only Y (luminance)), the display characterization is done now.</p>
<p>If you need to perform chromaticity calibration, please go to <strong><em>&quot;Color Calculator&quot;</em></strong> tab below.</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="chromaticity-cie1931-xyy-etc-estimation-procedure"><a name = "Chromaticity"> Chromaticity (CIE1931 xyY etc) estimation procedure </a></h1>
<p><img src="doc/imgs/11_Color_Calculator_tab.png" alt="Mcalibrator2 Color Calculator" /><br />
<strong>Mcalibrator2: Color Calculator tab (for performing chromaticity calibration)</strong></p>
<ol>
<li>First, to estimate chromaticity by a simple linear transformation, please load CIE1931 xyY values for each of the RGB phosphors at their maximum levels. To do this, please press the <strong><em>&quot;Load/measure RGB&quot;</em></strong> button. The phosphor values measured/stored in the previous session are extracted and displayed on the CIE1931 chromaticity diagram as 3 circles and a triangle. The range of chromaticity values you can present with the current display is a region enclosed by this triangle.</li>
</ol>
<p><img src="doc/imgs/12_Color_Calculator_tab_after_loading_phosphors.png" alt="Mcalibrator2 Color Calculator after loading phosphors" /><br />
<strong>Mcalibrator2: Color Calculator tab after loading CIE1931 xy values of the RGB phosphors at their maximum level.</strong></p>
<ol>
<li>Then, if you want to use the CLUTs generated in the previous step, please set the <strong><em>LUT</em></strong> radio-button to ON (default). If you want to use the raw RGB values without the reference CLUTs, please set the <strong><em>RGB</em></strong> radio-button to ON. If the RGB radio-button is ON, you can directly set RGB values on the <strong><em>&quot;you want to measure&quot;</em></strong> edit box. Please use this option when you want to simply measure RGB values of your stimuli.</li>
<li>Next, please input CIE1931 xyY values you want to use in your experiment on <strong><em>&quot;x,y,Y&quot;</em></strong> editing window just below the <strong><em>&quot;you want (x1, y1, Y1; x2, y2, Y2; x3, y3,..)&quot;</em></strong> message box. Please describe 3 (x, y, Y) values with a comma (,) as a delimiter. If you want to set multiple values, please use a semi-colon (;) to separate each of CIE 1931 xyY values. The format is thus as below.<br />
<strong>x1,y1,Y1; x2,y2,Y2; x3,y3,Y3;...</strong></li>
<li>You can also load these CIE1931 xyY values from a text file. To do this, please press the <strong><em>&quot;load&quot;</em></strong> button. The CIE1931 xyY values in the text file should be described with commas and semi-colons as delimiters as below.<br />
<strong><em>x1, y1, Y1;</em></strong><br />
<strong><em>x2, y2, Y2;</em></strong><br />
<strong><em>x3, y3, Y3;</em></strong><br />
<strong><em>...</em></strong><br />
</li>
<li>After setting xyY values you want, please press <strong><em>&quot;convert xyY&quot;</em></strong> button. If the LUT radio-button is ON, the xyY values are converted to <strong>CLUT IDs</strong>. If the RGB radio-button is ON, the raw RGB values required are calculated by a simple linear transformation. The estimated values are presented on the <strong><em>&quot;LUT (or RGB)&quot;</em></strong> edit box on the right side.</li>
<li>To measure actual CIE1931 xyY values for these initial estimations, please press the <strong><em>&quot;measure&quot;</em></strong> button. The chromaticities for the estimated RGB values are successively measured. The results are presented on the <strong><em>&quot;x,y,Y&quot;</em></strong> and <strong><em>&quot;LUT(or RGB)&quot;</em></strong> edit boxes just below the <strong><em>&quot;results (x1, y1, Y1; x2, y2, Y2; x3, y3,..)&quot;</em></strong> message box. In addition, the CIE1931 xy values you want and the actual measures for the estimations are plotted on the <strong><em>&quot;CIE1931 chromaticity diagram&quot;</em></strong> window by a circle (what you want) and a cross (actual measurement). If these two values are close enough, the chromaticity calibration is done successfully.</li>
</ol>
<p><img src="doc/imgs/12_Color_Calculator_tab_single_estimation.png" alt="Mcalibrator2 Color Calculator tab single estimation" /><br />
<strong>Mcalibrator2: Color Calculator tab, single color estimation result</strong></p>
<ol>
<li>If the estimations are not good, you need to adjut <strong><em>LUT IDs</em></strong> or <strong><em>RGB</em></strong> values by an automatic chromaticity estimation/correction method.</li>
</ol>
<ul>
<li>Mcalibrator2 currently has 7 automatic chromaticity estimation methods;</li>
</ul>
<ol>
<li><strong><em>recursive linear estimations based on a least-squares method with random local-value samplings</em></strong>,<br />
</li>
<li><strong><em>recursive linear estimations based on a least-squares method with grid local-value samplings</em></strong>,</li>
<li><strong><em>adjusting residuals by linear coeeficient estimations</em></strong>,<br />
</li>
<li><strong><em>a non-linear direct search algorithm --- Nelder-Mead Simplex</em></strong>,<br />
</li>
<li><strong><em>a linear/nonlinear hybrid estimation --- recursive linear estimations + Nelder-Mead Simplex</em></strong>,<br />
</li>
<li><strong><em>a line search algorithm --- Brent-Powell with Coggins/Golden-section</em></strong>,<br />
</li>
<li><strong><em>a linear/nonlinear hybrid estimation --- recursive linear estimations + Brent-Powell with Coggins/Golden-section</em></strong>.<br />
For more details of the estimation algorithms, please see comments on the source codes of Mcalibrator2 and see the paper on this software (<a href="http://www.journalofvision.org/content/13/6/20.long">Ban and Yamamoto, 2013, Journal of Vision</a>). You can select one of these methods by using the dropdown-box next to the <strong><em>&quot;measure&quot;</em></strong> button. The estimation for one chromaticity will take 1-5 min. After finishing the estimations, the results are presented on the <strong><em>&quot;x,y,Y&quot;</em></strong> and <strong><em>&quot;LUT(or RGB)&quot;</em></strong> edit boxes just below the <strong><em>&quot;results (x1, y1, Y1; x2, y2, Y2; x3, y3,..)&quot;</em></strong> message. In addition, the CIE1931 xy values you want and the actual measured values for the estimations are plotted on the <strong><em>&quot;CIE1931 chromaticity diagram&quot;</em></strong> window by a circle (what you want) and a cross (actual measurement).</li>
</ol>
<p><img src="doc/imgs/13_Color_Calculator_tab_selection_of_estimation_methods.png" alt="Mcalibrator2 Color Calculator tab selection of estimation methods" /><br />
<strong>Mcalibrator2: Color Calculator tab, the dropdown-list for selecting a chromaticity estimation method</strong></p>
<p><img src="doc/imgs/14_Color_Calculator_tab_automatic_color_estimations.png" alt="Mcalibrator2 Color Calculator tab automatic color estimations" /><br />
<strong>Mcalibrator2: Color Calculator tab, results of automatic chromaticity calibration (50 chromaticities)</strong></p>
<ol>
<li>To view the detailed chromaticity estimation values, please press the <strong><em>&quot;view&quot;</em></strong> button. The estimation results, residuals etc. are displayed on the MATLAB console window.</li>
<li>To save the estimation results, please press the <strong><em>&quot;save&quot;</em></strong> button. The results are saved as a <em>.mat file to </em><strong>~/Mcalibrator2/data/(date etc.)</strong>* like <strong><em>&quot;estimate_files_001.txt&quot;</em></strong> , <strong><em>&quot;estimate_files_002.txt&quot;</em></strong> ,... (file prefixex _001, _002,... are added automatically). Please be careful that <strong><em>no result will be saved automatically</em></strong> without pressing the <strong><em>&quot;save&quot;</em></strong> button.</li>
<li>If you can reproduce chromaticity values you want accurately enough, all the calibration procedures are completed. If the results are not good, please retry the estimations using different methods.</li>
</ol>
<p><a href="#Menu">return to menu</a></p>
<h1 id="about-tab"><a name = "About"> About tab </a></h1>
<p><img src="doc/imgs/15_about_tab.png" alt="Mcalibrator2 About tab" /><br />
<strong>Mcalibrator2: about tab</strong></p>
<p><img src="doc/imgs/16_display_test.png" alt="Mcalibrator2 display test" /><br />
<strong>Mcalibrator2: display test</strong></p>
<p><img src="doc/imgs/17_color_flickering_test.png" alt="Mcalibrator2 color flickering test" /><br />
<strong>Mcalibrator2: color flickering test</strong></p>
<p>On the <strong><em>&quot;About&quot;</em></strong> tab, the details of Mcalibrator2 software packages are displayed. If you press the <strong><em>&quot;display test&quot;</em></strong> button on this tab, you can perform several simple display tests.<br />
Furthremore, by pressing the <strong><em>&quot;parameters&quot;</em></strong> button, you can change the detailed gamma-correction, LUT generation, and chromaticity estimation parameters as you like. <strong><em>However, changing those default values affect the performance and accuracies of the Mcalibrator2 functions. Please be careful.</em></strong></p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="how-to-make-mcalibrator2-communicate-with-your-own-colorimeters"><a name = "CustomColorimeter"> How to make Mcalibrator2 communicate with your own colorimeter(s) </a></h1>
<p>Currently, we have already prepared subrountines for Mcalibrator2 to communicate with</p>
<ul>
<li><em>Konica-Minolta CS-100A (tested),</em><br />
</li>
<li><em>Admesy Brontes-LL (tested),</em><br />
</li>
<li><em>Photo-research PR-650 (tested),</em><br />
</li>
<li><em>Cambridge Research Systems ColorCal2 (tested)</em><br />
</li>
<li><em>some more but NOT fully tested.</em></li>
</ul>
<p>You can also use your own colorimeter(s) with Mcalibrator2 if you write some simple codes in MATLAB. To do this, you need to<br />
1.Register your own colorimeter(s) to an apparatus-list file, and<br />
2.Create a class file which defines a MATLAB object for your own colorimeter to communicate with Mcalibrator2.</p>
<p>To register your colorimeter, please edit <strong><em>~/Mcalibrator2/subfunctions/colorimeter/colorimeter_list.m</em></strong><br />
By default, several photometers are already registered as below in this file.</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">colorimeters{<span class="fl">1</span>}={<span class="st">&#39;Photo Research PR-650&#39;</span>,<span class="st">&#39;pr650&#39;</span>,<span class="fl">0</span>};
colorimeters{<span class="fl">2</span>}={<span class="st">&#39;KONICA-MINOLTA CS-100A&#39;</span>,<span class="st">&#39;cs100a&#39;</span>,<span class="fl">0</span>};
colorimeters{<span class="fl">3</span>}={<span class="st">&#39;KONICA-MINOLTA CS-150&#39;</span>,<span class="st">&#39;cs150&#39;</span>,<span class="fl">1</span>};
colorimeters{<span class="fl">4</span>}={<span class="st">&#39;Admesy Brontes-LL (64bit)&#39;</span>,<span class="st">&#39;brontesLL&#39;</span>,<span class="fl">1</span>};
colorimeters{<span class="fl">5</span>}={<span class="st">&#39;Admesy Brontes-LL (32bit)&#39;</span>,<span class="st">&#39;brontesLL32&#39;</span>,<span class="fl">1</span>};
colorimeters{<span class="fl">6</span>}={<span class="st">&#39;Cambridge Research Systems ColorCAL2 Win-USB&#39;</span>,<span class="st">&#39;colorcal&#39;</span>,<span class="fl">1</span>};
<span class="co">%colorimeters{7}={&#39;Cambridge Research Systems ColorCAL2 (PTB, not tested)&#39;,&#39;colorcal2&#39;,1};</span>
colorimeters{<span class="fl">7</span>}={<span class="st">&#39;Cambridge Research Systems ColorCAL CDC (Virtual Port)&#39;</span>,<span class="st">&#39;colorcalcdc&#39;</span>,<span class="fl">0</span>};
colorimeters{<span class="fl">8</span>}={<span class="st">&#39;Cambridge Research Systems OptiCal (not tested)&#39;</span>,<span class="st">&#39;optical&#39;</span>,<span class="fl">0</span>};
colorimeters{<span class="fl">9</span>}={<span class="st">&#39;International Light IL1700&#39;</span>,<span class="st">&#39;il1700&#39;</span>,<span class="fl">0</span>};
colorimeters{<span class="fl">10</span>}={<span class="st">&#39;Dummy Colorimeter (for Debug)&#39;</span>,<span class="st">&#39;dummy_colorimeter&#39;</span>,<span class="fl">0</span>};</code></pre></div>
<p>Therefore, please add your colorimeter(s) as <strong><em>colorimeters{11}</em></strong> , <strong><em>colorimeters{12}</em></strong> ,...or you can fully re-write this list.<br />
The first variable is <strong><em>a name of your colorimeter displayed on Mcalibrator2</em></strong>, the second variable is <strong><em>a name of a function for your colorimeter to communicate with Mcalibrator2 (= a class file name to generate a MATLAB object)</em></strong> , and the third variable is <strong><em>a value (0/1) to specify the way of communication (0=serial connection, 1=USB connection)</em></strong> .</p>
<p>Then, please generate a MATLAB class file (<em>.m) which describes the details of the way of communication. Specifically, please define a MATLAB object with a &quot;classdef&quot; keyword. </em><strong>The communication object should have 2 properties and 4 methods described below</strong>*.</p>
<pre><code>- Property (Hidden)
   portname,
   rscom

- Property (public)
   init_flg

- Method
   gen_port,
   reset_port,
   initialize,
   measure</code></pre>
<p>Furthermore, in creating your own class, you have to use exactly the same input/output variables etc with the other communication objects.<br />
As examples, please see two sample MATLAB codes below. The sample, <em>&quot;cs100a.m&quot;</em>, is to create a communication object through a serial (RS232C) port. The sample, <em>&quot;brontesLL.m&quot;</em>, is to communicate via a USB port.</p>
<ol>
<li><strong><em>Sample 1: ~/Mcalibrator2/subfunctions/colorimeter/cs100a.m (a serial communication)</em></strong></li>
</ol>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">classdef cs100a
  <span class="co">% a class to manipulate MINOLTA CS-100A from MATLAB through a serial port connection</span>
  <span class="co">%</span>
  <span class="co">% Created    : &quot;2012-04-11 09:23:57 ban&quot;</span>
  <span class="co">% Last Update: &quot;2016-09-13 18:19:02 ban&quot;</span>

  properties (Hidden) <span class="co">%(SetAccess = protected)</span>
    portname=<span class="st">&#39;COM1&#39;</span>; <span class="co">% id of serial port to communicate with CS-100A</span>
    rscom=[];  <span class="co">% serial port object</span>
  end

  properties
    init_flg=<span class="fl">0</span>;
  end

  methods

    <span class="co">% constructor</span>
    function obj=cs100a(port_name)
      if nargin==<span class="fl">1</span> &amp;&amp; ~isempty(port_name)
        obj.portname=port_name;
      end
    end

    <span class="co">% destructor</span>
    function obj=delete(obj)
      if ~isempty(obj.rscom)
        fclose(obj.rscom);
        delete(obj.rscom);
        obj.rscom=[];
        obj.init_flg=<span class="fl">0</span>;
      end
    end

    <span class="co">% create/open a serial port connection to communicate with CS-100A</span>
    function obj=gen_port(obj,port_name)
      if nargin&gt;<span class="fl">1</span> &amp;&amp; ~isempty(port_name)
        obj.portname=port_name;
        obj.rscom=serial(obj.portname);
      elseif ~isempty(obj.portname)
        obj.rscom=serial(obj.portname);
      else
        error(<span class="st">&#39;set a name of serial port.&#39;</span>);
      end

      set(obj.rscom,<span class="st">&#39;DataBits&#39;</span>,<span class="fl">7</span>,<span class="st">&#39;BaudRate&#39;</span>,<span class="fl">4800</span>,<span class="st">&#39;Parity&#39;</span>,<span class="st">&#39;even&#39;</span>,<span class="st">&#39;StopBits&#39;</span>,<span class="fl">2</span>,<span class="st">&#39;Terminator&#39;</span>,<span class="st">&#39;CR/LF&#39;</span>);

      fopen(obj.rscom);

      <span class="co">% NEW for MATLAB R14</span>
      <span class="co">% After initializing the serial port using FOPEN,</span>
      <span class="co">% you should set the RTS and DTR pins to low using the following code:</span>
      set (obj.rscom, <span class="st">&#39;DataTerminalReady&#39;</span> ,<span class="st">&#39;off&#39;</span>) ;
      set (obj.rscom, <span class="st">&#39;RequestToSend&#39;</span> ,<span class="st">&#39;off&#39;</span>) ;
      <span class="co">% and pause for some msec</span>
      pause(<span class="fl">0.3</span>);

      <span class="co">% When the RTS and DTR pins are subsequently set high at any time using the following code,</span>
      <span class="co">% the voltage at the pins will be as expected:</span>
      set (obj.rscom, <span class="st">&#39;DataTerminalReady&#39;</span> ,<span class="st">&#39;on&#39;</span>) ;
      set (obj.rscom, <span class="st">&#39;RequestToSend&#39;</span> ,<span class="st">&#39;on&#39;</span>) ;

      obj.init_flg=<span class="fl">1</span>;
    end

    <span class="co">% reset a serial port connection</span>
    function obj=reset_port(obj)
      fclose(obj.rscom);
      delete(obj.rscom);
      obj.rscom=[];
      obj.init_flg=<span class="fl">0</span>;
    end

    <span class="co">% initialize CS-100A</span>
    function [obj,check,integtime]=initialize(obj,integtime)

      if isempty(obj.rscom), error(<span class="st">&#39;serial connection has not been established. run gen_port first.&#39;</span>); end

      <span class="co">% NOTICE 1</span>
      <span class="co">%</span>
      <span class="co">% First, you must confirm electric (electrical) power supply &#39;OFF&#39;.</span>
      <span class="co">% Then, press &#39;ON&#39; button of the CS-100A, pushing &#39;F&#39; key.</span>
      <span class="co">% Check whether the character &#39;c&#39; was shown on the bottom right corner of the CS-100A display.</span>
      <span class="co">% Through these process, CS-100A will be set as bothway communications mode.</span>

      <span class="co">% NOTICE 2</span>
      <span class="co">% &#39;integtime&#39; is a dummy variable to match the format with the other class.</span>
      <span class="co">% It is not used in this function.</span>

      fprintf(obj.rscom, <span class="st">&#39;MDS,07&#39;</span>); <span class="co">% Set Up Measurement Parameters.</span>
      pause(<span class="fl">0.1</span>);

      <span class="co">% Checking setting parameters.</span>
      results=fgets(obj.rscom);

      if ~strcmp(results(<span class="fl">1</span>:<span class="fl">4</span>),<span class="st">&#39;OK00&#39;</span>)
        disp(<span class="st">&#39;setup error. check CS-100A and cable connections.&#39;</span>);
        return;
      end

      <span class="co">% Format -MDS</span>
      <span class="co">%             &#39;MDS,[][]&#39;</span>
      <span class="co">%               00 : MINOLTA Standard Calibration Mode</span>
      <span class="co">%               01 : Optional Calibration Mode</span>
      <span class="co">%               04 : Chromaticity Measurement Mode</span>
      <span class="co">%               05 : Color Difference Measurement Mode</span>
      <span class="co">%               06 : Measurement Response Time --- 100ms Fast Mode</span>
      <span class="co">%               07 : Measurement Response Time --- 400ms Slow Mode</span>

      <span class="co">% Error Check Command Description</span>
      <span class="co">%               ER00 : Command Error, or Parameters Error</span>
      <span class="co">%               ER11 : Memory Values Error</span>
      <span class="co">%               ER20 : EEPROM Error</span>
      <span class="co">%               ER30 : Battely Out Error</span>

      fprintf(obj.rscom, <span class="st">&#39;MDS,04&#39;</span>); <span class="co">% Set Up Measurement Parameters.</span>
      pause(<span class="fl">0.1</span>);

      <span class="co">% Checking setting parameters.</span>
      results=fgets(obj.rscom);

      if strcmp(results(<span class="fl">1</span>:<span class="fl">4</span>),<span class="st">&#39;OK00&#39;</span>)
        check = <span class="fl">0</span>;
      else
        check = <span class="fl">1</span>;
      end
    end

    <span class="co">% measure CIE1931 xyY of the target</span>
    function [qq,Y,x,y,obj]=measure(obj,integtime)

      if isempty(obj.rscom), error(<span class="st">&#39;serial connection has not been established. run gen_serial first.&#39;</span>); end
      if nargin&lt;<span class="fl">2</span> || isempty(integtime), integtime=<span class="fl">500</span>; end <span class="co">%#ok</span>

      <span class="co">% NOTICE 1</span>
      <span class="co">% Terminator (delimiter) should be CR/LF (CR+LF).</span>
      <span class="co">% This terminator was set by CreateSerialObjectMINOL.</span>

      <span class="co">% NOTICE 2</span>
      <span class="co">% &#39;integtime&#39; is a dummy variable to match the format with the other class.</span>
      <span class="co">% It is not used in this function.</span>

      fprintf(obj.rscom, <span class="st">&#39;MES&#39;</span>); <span class="co">% Measure Light Under Conditions defined by the &#39;MDS&#39; command line.</span>
      pause(<span class="fl">0.1</span>);

      <span class="co">% Format -MES</span>
      <span class="co">%       output : normal</span>
      <span class="co">%                   &#39;OK00,+[][][][][][],+.[][][][],+.[][][][]&#39;</span>
      <span class="co">%                     notice : here, + may chage to -</span>
      <span class="co">%              : luminance and chromaticity over the measurement range</span>
      <span class="co">%                   &#39;ER10&#39;</span>
      <span class="co">%              : chromaticity over the measurement range</span>
      <span class="co">%                   &#39;OK11,+[][][][][][],+.0000,+.0000&#39;</span>
      <span class="co">%                     notice : here, + may chage to -</span>
      <span class="co">%              : luminance over the measurement range</span>
      <span class="co">%                   &#39;OK12,-999999,+.[][][][],+.[][][][]&#39;</span>
      <span class="co">%                     notice : here, + may chage to -</span>
      <span class="co">%              : values are over the display or maasurement range</span>
      <span class="co">%                   &#39;ER12&#39;</span>
      <span class="co">%              : luminance under the masurement range</span>
      <span class="co">%                   &#39;OK13,+[][][][][][],+.[][][][],+.[][][][]&#39;</span>
      <span class="co">%                     notice : here, + may chage to -</span>

      results=fscanf(obj.rscom);
      <span class="co">%if strcmp(results(1:4),&#39;OK00&#39;)</span>
        qq=<span class="fl">0</span>;
        Y=str2num(results(<span class="fl">6</span>:<span class="fl">12</span>)); <span class="co">%#ok</span>
        x=str2num(results(<span class="fl">14</span>:<span class="fl">19</span>)); <span class="co">%#ok</span>
        y=str2num(results(<span class="fl">21</span>:<span class="fl">26</span>)); <span class="co">%#ok</span>
        return
      <span class="co">%end</span>

      <span class="co">% numretry=1; qq=1;</span>
      <span class="co">% while numretry&lt;=5 &amp;&amp; qq~=0</span>
      <span class="co">%   numretry=numretry+1;</span>
      <span class="co">%   if strcmp(results(1:4),&#39;OK00&#39;)</span>
      <span class="co">%     Y=str2num(results(6:12)); %#ok</span>
      <span class="co">%     x=str2num(results(14:19)); %#ok</span>
      <span class="co">%     y=str2num(results(21:26)); %#ok</span>
      <span class="co">%     qq=0;</span>
      <span class="co">%   else</span>
      <span class="co">%     if strcmp(results(1:4),&#39;OK12&#39;)</span>
      <span class="co">%       fprintf(obj.rscom, &#39;MDS,06&#39;); % fast mode</span>
      <span class="co">%       fscanf(obj.rscom); % clear data</span>
      <span class="co">%     elseif strcmp(results(1:4),&#39;OK13&#39;)</span>
      <span class="co">%       fprintf(obj.rscom, &#39;MDS,07&#39;); % slow mode</span>
      <span class="co">%       fscanf(obj.rscom); % clear data</span>
      <span class="co">%     end</span>
      <span class="co">%     pause(0.1);</span>
      <span class="co">%     fprintf(obj.rscom, &#39;MES&#39;);</span>
      <span class="co">%     pause(0.1);</span>
      <span class="co">%     results=fscanf(obj.rscom);</span>
      <span class="co">%   end</span>
      <span class="co">% end</span>
      <span class="co">%</span>
      <span class="co">% if numretry&gt;5</span>
      <span class="co">%   Y=str2num(results(6:12)); %#ok</span>
      <span class="co">%   x=str2num(results(14:19)); %#ok</span>
      <span class="co">%   y=str2num(results(21:26)); %#ok</span>
      <span class="co">% end</span>

      <span class="co">% Descriptions</span>
      <span class="co">% qq                  : Measurement quality code (OK00 = O.K.)</span>
      <span class="co">% U                   : Unit of Measured Luminace, always 0 with CS-100A</span>
      <span class="co">% Y                   : +(-)[][][][][][] 1931 CIE Y (units indicated by U)</span>
      <span class="co">% x                   : +(-).[][][][] 1931 CIE x</span>
      <span class="co">% y                   : +(-).[][][][] 1931 CIE y</span>
    end

  end <span class="co">% methods</span>

end <span class="co">% classdef cs100a</span></code></pre></div>
<ol>
<li><strong><em>Sample 2: ~/Mcalibrator2/subfunctions/colorimeter/brontesLL.m (a USB communication)</em></strong></li>
</ol>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">classdef brontesLL
  <span class="co">% a class to manipulate Admesy Brontes-LL from MATLAB on Windows OS via a USB port</span>
  <span class="co">%</span>
  <span class="co">% [methods]</span>
  <span class="co">% brontesLL=brontesLL.gen_port(&#39;PORT&#39;)             : generate USB port to communicate with Brontes-LL</span>
  <span class="co">% brontesLL=brontesLL.initialize(integration_time) : initialize measurement parameters</span>
  <span class="co">% brontesLL=brontesLL.reset_port()                 : reset USB port connection</span>
  <span class="co">% [qq,Y,x,y,brontesLL]=brontesLL.measure(integration_time) : measure CIE1931 xyY</span>
  <span class="co">% command=brontesLL.write(&#39;command&#39;)               : send command to Brontes-LL through USB connection</span>
  <span class="co">% results=brontesLL.read(number_of_bytes)          : read resutls etc from Brontes-LL through USB connection</span>
  <span class="co">%</span>
  <span class="co">% [requirement]</span>
  <span class="co">% 1. NI-VISA (National Instruments) or lib_usb_win32 driver</span>
  <span class="co">% 2. Admesy_sdk.zip distributed by Admesy, Netherlands</span>
  <span class="co">%</span>
  <span class="co">% [how to use]</span>
  <span class="co">% To use this class on Windows OS with Admesy BrontesLL, please first install</span>
  <span class="co">% Admesy SDK distributed by Admesy, Netherlands.</span>
  <span class="co">% After installing the sdk, please copy three files below</span>
  <span class="co">% ~/Admesy SDK/libraries/libusbtmc/bin/x64/libusbtmc_x64.dll</span>
  <span class="co">% ~/Admesy SDK/libraries/libusbtmc/bin/x86/libusbtmc_x86.dll</span>
  <span class="co">% ~/Admesy SDK/libraries/libusbtmc/include/libusbtmc.h</span>
  <span class="co">% to the same directory with this class file.</span>
  <span class="co">%</span>
  <span class="co">% [license details about Admesy SDK]</span>
  <span class="co">% Admesy SDK license agreement</span>
  <span class="co">% By installing the Admesy SDK, you agree to the following terms.</span>
  <span class="co">% 1) The Admesy SDK can be used freely with Admesy instruments with no limitations regarding installation.</span>
  <span class="co">% 2) Use of this library with other brands instruments is not permitted.</span>
  <span class="co">% 3) This library is not licensed to third parties without the use of Admesy Instruments.</span>
  <span class="co">% 4) Distribution of the files is only permitted with Admesy instruments or demo software.</span>
  <span class="co">% Distributions should always include this end-user license.</span>
  <span class="co">% 5) Modifications/renaming of DLL&#39;s are not permitted.</span>
  <span class="co">% 6) Functions that are exported but undocumented, are not supported.</span>
  <span class="co">% 7) This Admesy License agreement does not contain any 3th party licenses such as Labview,NI-Visa</span>
  <span class="co">%     or Microsoft Visual Studio. 3th party software may require a separate license agreement.</span>
  <span class="co">% 8) Libusbtmc can be used in conjunction with libusb. This does not require a separate license.</span>
  <span class="co">% 9) The library is not distributed with source code. It is not open source, but free to use.</span>
  <span class="co">% 10) The Admesy colour SDK is developed for use on the Windows Operating system (XP32bit, Vista, Win7,</span>
  <span class="co">%     Win8) and with general hardware in mind. Admesy does not guarantee full functionality on all operating</span>
  <span class="co">%     systems/hardware. Admesy Instruments can be operated on Linux and Mac OSX or other Operating systems,</span>
  <span class="co">%     but that is not supported by this SDK.</span>
  <span class="co">% 11) This SDK and its components are free to use under above terms and may not be sold to 3rd parties.</span>
  <span class="co">%</span>
  <span class="co">%</span>
  <span class="co">% Created    : &quot;2012-10-29 05:28:07 ban&quot;</span>
  <span class="co">% Last Update: &quot;2017-06-30 10:17:52 ban&quot;</span>

  properties (Hidden) <span class="co">%(SetAccess = protected);</span>
    <span class="co">% id of USB port to communicate with Brontes-LL. This is a dummy variable to match with the other function</span>
    portname=<span class="st">&#39;USB0::0x1781::0x0E98::00032::INSTR&#39;</span>;
    rscom=[];  <span class="co">% serial port object. This is a dummy variable to match with the other function</span>
    deviceID=<span class="st">&#39;&#39;</span>;
    devicehandle=<span class="fl">0</span>;
    TIME_OUT=<span class="fl">5000</span>; <span class="co">% time out of the communication in msec</span>
  end

  properties
    init_flg=<span class="fl">0</span>;
  end

  methods

    <span class="co">% constructor</span>
    function obj=brontesLL(port_name)
      if ~libisloaded(<span class="st">&#39;usbtmc&#39;</span>)
        if strfind(computer(<span class="st">&#39;arch&#39;</span>),<span class="st">&#39;64&#39;</span>) <span class="co">% if working on a 64-bit machine</span>
          <span class="co">%notfound=loadlibrary(&#39;libusbtmc_x64.dll&#39;,@admesy_libusbtmc_matlab,&#39;alias&#39;,&#39;usbtmc&#39;);</span>
          notfound=loadlibrary(<span class="st">&#39;libusbtmc_x64.dll&#39;</span>,<span class="st">&#39;libusbtmc.h&#39;</span>,<span class="st">&#39;alias&#39;</span>,<span class="st">&#39;usbtmc&#39;</span>);
        else <span class="co">% if working on a 32-bit machine.</span>
          <span class="co">%notfound=loadlibrary(&#39;libusbtmc_x86.dll&#39;,@admesy_libusbtmc_matlab,&#39;alias&#39;,&#39;usbtmc&#39;);</span>
          notfound=loadlibrary(<span class="st">&#39;libusbtmc_x86.dll&#39;</span>,<span class="st">&#39;libusbtmc.h&#39;</span>,<span class="st">&#39;alias&#39;</span>,<span class="st">&#39;usbtmc&#39;</span>);
        end
        if ~isempty(notfound)
          if strfind(computer(<span class="st">&#39;arch&#39;</span>),<span class="st">&#39;64&#39;</span>) <span class="co">% if working on a 64-bit machine</span>
            error(<span class="st">&#39;library: libusbtmc_x64.dll &amp; libusbtmc.h not found. check input variable.&#39;</span>);
          else <span class="co">% if working on a 32-bit machine.</span>
            error(<span class="st">&#39;library: libusbtmc_x86.dll &amp; libusbtmc.h not found. check input variable.&#39;</span>);
          end
        end
      end
      if nargin==<span class="fl">1</span> &amp;&amp; ~isempty(port_name)
        obj.portname=port_name;
      end
    end

    <span class="co">% destructor</span>
    function obj=delete(obj)
      obj.rscom=[];
      obj.init_flg=<span class="fl">0</span>;
      if obj.devicehandle~=<span class="fl">0</span>, calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_close&#39;</span>,obj.devicehandle); end
      unloadlibrary(<span class="st">&#39;usbtmc&#39;</span>);
    end

    <span class="co">% create/open a USB port connection to communicate with Brontes-LL</span>
    function obj=gen_port(obj,port_name) <span class="co">%#ok</span>
      <span class="co">% port_name is a dummy variable to match nargin with the other functions</span>
      if obj.init_flg==<span class="fl">1</span>
        disp(<span class="st">&#39;USB connection with Brontes-LL is already established&#39;</span>);
      else
        disp(<span class="st">&#39;starting USB communication with Brontes-LL&#39;</span>);

        <span class="co">% find Brontes-LL device with its ID</span>
        usbtmcdevices=libpointer(<span class="st">&#39;stringPtr&#39;</span>,repmat(<span class="st">&#39; &#39;</span>,<span class="fl">1</span>,<span class="fl">255</span>));
        [dummy,obj.deviceID]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_find_devices&#39;</span>,usbtmcdevices);
        clear usbtmcdevices;
        if obj.deviceID==<span class="fl">0</span>
          warning(<span class="st">&#39;USB communication can not be established. check cable connection&#39;</span>); <span class="co">%#ok</span>
          obj.init_flg=<span class="fl">0</span>;
        else
          <span class="co">% open USB port</span>
          [dummy,obj.deviceID,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_open&#39;</span>,obj.deviceID,<span class="fl">0</span>);
          if obj.devicehandle==<span class="fl">0</span>
            error(<span class="st">&#39;USB port not opend. check cable connection&#39;</span>);
          end
          obj.init_flg=<span class="fl">1</span>;
        end

      end
    end

    <span class="co">% reset a serial port connection</span>
    function obj=reset_port(obj)
      obj.rscom=[];
      obj.init_flg=<span class="fl">0</span>;
      calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_close&#39;</span>,obj.devicehandle);
      obj.deviceID=<span class="st">&#39;&#39;</span>;
      obj.devicehandle=<span class="fl">0</span>;
      [dummy,obj.deviceID,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_open&#39;</span>,obj.deviceID,<span class="fl">0</span>);
    end

    <span class="co">% initialize Brontes-LL</span>
    function [obj,check,integtime]=initialize(obj,integtime)
      if nargin&lt;=<span class="fl">2</span> || isempty(integtime), integtime=<span class="fl">40000</span>; end
      integtime=min(integtime,<span class="fl">500000</span>);
      integtime=max(<span class="fl">5000</span>,integtime);

      check=<span class="fl">0</span>;
      try
        <span class="co">% reset &amp; clear the device</span>
        [dummy,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,<span class="st">&#39;:*RST&#39;</span>,obj.TIME_OUT);
        [dummy,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,<span class="st">&#39;:*CLS&#39;</span>,obj.TIME_OUT);

        <span class="co">% set gain</span>
        [dummy,obj.deviceID]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,<span class="st">&#39;:SENSE:GAIN 1&#39;</span>,obj.TIME_OUT);

        <span class="co">% set num of samples to be averaged</span>
        [dummy,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,<span class="st">&#39;:SENSE:AVERAGE 10&#39;</span>,obj.TIME_OUT);

        <span class="co">% set integration time in usec</span>
        [dummy,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,sprintf(<span class="st">&#39;:SENSE:INT %d&#39;</span>,integtime),obj.TIME_OUT);

        <span class="co">% set sampling band width</span>
        [dummy,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,<span class="st">&#39;:SENSE:SBW small&#39;</span>,obj.TIME_OUT);
      catch <span class="co">%#ok</span>
        check=<span class="fl">1</span>;
      end
    end

    <span class="co">% measure CIE1931 xyY of the target</span>
    function [qq,Y,x,y,obj]=measure(obj,integtime)

      if ~obj.init_flg, disp(<span class="st">&#39;initialization has not completed. open port and initialize the apparatus first.&#39;</span>); return; end
      if nargin&lt;<span class="fl">2</span> || isempty(integtime), integtime=<span class="fl">20000</span>*<span class="fl">2</span>; end
      integtime=min(integtime,<span class="fl">500000</span>);
      integtime=max(<span class="fl">5000</span>,integtime);

      qq=<span class="fl">1</span>; counter=<span class="fl">0</span>;
      while qq~=<span class="fl">0</span> &amp;&amp; counter&lt;<span class="fl">5</span>
        counter=counter+<span class="fl">1</span>;
        if counter&gt;<span class="fl">2</span>
          if qq&gt;<span class="fl">0</span>
            integtime=min(ceil(integtime*<span class="fl">0.8</span>),<span class="fl">5000</span>);
          elseif qq&lt;<span class="fl">0</span>
            integtime=min(ceil(integtime*<span class="fl">1.2</span>),<span class="fl">5000000</span>);
          end
          [dummy,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,sprintf(<span class="st">&#39;:SENSE:INT %d&#39;</span>,integtime),obj.TIME_OUT);
        end

        <span class="co">% [about output format of measured CIE1931 xyY]</span>
        <span class="co">%</span>
        <span class="co">% :MEASure command returns their result in ASCII formated floating point as shown below :</span>
        <span class="co">% (Y,x,y,clip,noise) %f,%f,%f,%d,%d\n;</span>
        <span class="co">%</span>
        <span class="co">% The integration time setting can be varied from 0.5ms to 5s.</span>
        <span class="co">% It is specified in microsecond. Results from the Brontes-LL colorimeter include a clip and noise</span>
        <span class="co">% indication which indicate whether the measured light is too bright (clip) or too low (noise).</span>
        <span class="co">% When clipping is detected, the resulting colour will not be correct and a lower integration time</span>
        <span class="co">% should be chosen. When noise is detected, a larger integration time should be chosen.</span>

        [dummy,obj.devicehandle]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,<span class="st">&#39;:meas:YXY&#39;</span>,obj.TIME_OUT);
        bytecount=<span class="fl">64</span>;
        data_ptr=libpointer(<span class="st">&#39;uint8Ptr&#39;</span>,zeros(<span class="fl">1</span>,bytecount));

        <span class="co">% [Note from Admesy SDK manual about the use of Bytecount]</span>
        <span class="co">%</span>
        <span class="co">% The third input variable of usbtmc_read is Bytecount.</span>
        <span class="co">% The number of bytes that needs to be read may exceed the actual data that is available.</span>
        <span class="co">% However, assigning always a very large number is discouraged.</span>
        <span class="co">% For example when a &quot;:meas:XYZ&quot; command returns 36 bytes, you may ask for 64 bytes.</span>
        <span class="co">% When you use a &quot;:sample:Y&quot; function, you know exactly how many bytes should be returned.</span>
        <span class="co">% It is than best to input this exact number or just a little bit more.</span>
        <span class="co">% In case you read for example 65535 bytes for a &quot;:meas:XYZ: command, the internal library</span>
        <span class="co">% allocates 65535 bytes where it only gets 36bytes back. This works, but is inefficient in</span>
        <span class="co">% memory and execution time.</span>

        [dummy,obj.devicehandle,measured]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_read&#39;</span>,obj.devicehandle,data_ptr,uint32(bytecount),obj.TIME_OUT);
        clear data_ptr;

        val=sscanf(char(measured),<span class="st">&#39;%f,%f,%f,%d,%d\n&#39;</span>);
        if sum(measured)~=<span class="fl">0</span>
          if numel(val)~=<span class="fl">0</span>
            Y=val(<span class="fl">1</span>);
            x=val(<span class="fl">2</span>);
            y=val(<span class="fl">3</span>);
            clip=val(<span class="fl">4</span>);
            noise=val(<span class="fl">5</span>);
            qq=<span class="fl">0</span>;
            <span class="co">%if clip, qq=1; end</span>
            <span class="co">%if noise, qq=-1; end</span>
            <span class="co">%if clip==0 &amp;&amp; noise==0, qq=0; end</span>
          else
            qq=<span class="fl">1</span>; Y=[]; x=[]; y=[];
          end
        else
          if numel(val)&gt;<span class="fl">4</span>
            if val(<span class="fl">4</span>)==<span class="fl">0</span>
              warning(<span class="st">&#39;the measured light is too bright&#39;</span>); <span class="co">%#ok</span>
            elseif val(<span class="fl">5</span>)==<span class="fl">0</span>
              warning(<span class="st">&#39;the measured light is too dark&#39;</span>); <span class="co">%#ok</span>
            end
          else
            warning(<span class="st">&#39;measuring failed. check the cable connection&#39;</span>); <span class="co">%#ok</span>
          end
          qq=<span class="fl">1</span>; Y=[]; x=[]; y=[];
        end
      end
    end

    <span class="co">% write command to Brontes-LL through USB connection</span>
    function [obj,command]=write(obj,command)
      calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_write&#39;</span>,obj.devicehandle,command,obj.TIME_OUT);
    end

    <span class="co">% read results etc from Brontes-LL through USB connection</span>
    function [obj,results]=read(obj,bytecount)
      if nargin&lt;<span class="fl">2</span> || ismepty(bytecount), bytecount=<span class="fl">128</span>; end
      data_ptr=libpointer(<span class="st">&#39;uint8Ptr&#39;</span>,zeros(<span class="fl">1</span>,bytecount));
      [dummy,obj.devicehandle,results]=calllib(<span class="st">&#39;usbtmc&#39;</span>,<span class="st">&#39;usbtmc_read&#39;</span>,obj.devicehandle,data_ptr,uint32(bytecount),obj.TIME_OUT);
      results=char(results);
      clear data_ptr;
    end

  end <span class="co">% methods</span>

end <span class="co">% classdef brontesLL</span></code></pre></div>
<p>After completing these setups, please launch Mcalibrator2, check whether your own colorimeter is properly registered (if registered, your apparatus is listed in the dropdown-list on <strong><em>&quot;config&quot;</em></strong> tab), and check whether your colarimeter can communicate with Mcalibrator2.</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="how-to-add-your-own-chromaticity-estimation-methods-to-mcalibrator2"><a name = "CustomEstimation"> How to add your own chromaticity estimation methods to Mcalibrator2 </a></h1>
<p>You can easily add your own chromaticity estimation procedure(s) to Mcalibrator2 as you like. To do this, please</p>
<ol>
<li>Register your own estimation method(s) to a list of estimation-method file, and</li>
<li>Create MATLAB function(s) which describe your own chromaticity estimation procedure(s).</li>
</ol>
<p>To register your own chromaticity estimation method(s) to Mcalibrator2, please edit <strong><em>~/Mcalibrator2/subfunctions/colorcalculator/measurement_method_list.m</em></strong>.<br />
By default, eight chromaticity estimation methods are already registered in this file as below.</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">meas_methods{<span class="fl">1</span>}={<span class="st">&#39;Measure simply&#39;</span>,<span class="st">&#39;calculator_measure_simply&#39;</span>};
meas_methods{<span class="fl">2</span>}={<span class="st">&#39;[auto] Recursive linear estimation with unifrnd()&#39;</span>,<span class="st">&#39;calculator_auto_estimation_linear&#39;</span>};
meas_methods{<span class="fl">3</span>}={<span class="st">&#39;[auto] Recursive linear estimation with Grid&#39;</span>,<span class="st">&#39;calculator_auto_estimation_linear_grid&#39;</span>};
meas_methods{<span class="fl">4</span>}={<span class="st">&#39;[auto] Adjust residuals by linear coefficients&#39;</span>,<span class="st">&#39;calculator_auto_estimation_lincoeff&#39;</span>};
meas_methods{<span class="fl">5</span>}={<span class="st">&#39;[auto] Non-linear (Nelder-Mead Simplex)&#39;</span>,<span class="st">&#39;calculator_auto_estimation_nonlinear&#39;</span>};
meas_methods{<span class="fl">6</span>}={<span class="st">&#39;[auto] Linear/non-linear hybrid&#39;</span>,<span class="st">&#39;calculator_auto_estimation_hybrid&#39;</span>};
meas_methods{<span class="fl">7</span>}={<span class="st">&#39;[auto] Brent-Powell with Coggins/Golden-section&#39;</span>,<span class="st">&#39;calculator_auto_estimation_powell&#39;</span>};
meas_methods{<span class="fl">8</span>}={<span class="st">&#39;[auto] Linear/Brent-Powell hybrid&#39;</span>,<span class="st">&#39;calculator_auto_estimation_powell_hybrid&#39;</span>};</code></pre></div>
<p>Please add your method(s) as <strong><em>meas_methods{9}</em></strong> , <strong><em>meas_methods{10}</em></strong> ,..., or you can fully rewrite the list. The first variable is <strong><em>a name of your estimation method displayed on Mcalibrator2</em></strong>, the second variable is <strong><em>a name of the estimatin function</em></strong>.</p>
<p>You have to separately create a MATLAB function, which defines the details of your own chromaticity estimation procedure, and have to save it with the same name with the second varialbe in the list. The function should be located in <strong><em>~/Mcalibrator2/subfunctions/colorcalculator/</em></strong> directory.</p>
<p>Furtheremore, the function should have the <strong><em>three input variables</em></strong> listed below and have <strong><em>no output variable</em></strong>.</p>
<pre><code>hObject    : A handle to Mcalibrator2 Objects.
             Generally this variable is not used, but it is
             required to follow MATLAB GUI handling conventions.
eventdata  : A variable booked for a future version of MATLAB.
             This variable is also not used currently, but it is
             required to adjust a format with the other default
             functions of Mcalibrator2.
handles    : A structure which includes handles to child objects
             of Mcalibrator2 and user-defined data</code></pre>
<p>In addition, please declare the global variables below in your function with a &quot;global&quot; keyword.</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">global config;             <span class="co">% a structure which stores configuration of Mcalibrator2</span>
global colorimeterhandler; <span class="co">% an object to handle a colorimeter</span>
global displayhandler;     <span class="co">% an object to present a chromaticity on display</span>
global phosphers;          <span class="co">% CIE1931 xyY values of RGB phosphors at their maximum levels</span>
global flares;             <span class="co">% Flares (zero-level luminance) of RGB phosphers</span></code></pre></div>
<p>By using the global variables above and the input variable, &quot;handles&quot;, you can manipulate Mcalibrator2 through your own chromaticity estimation function.</p>
<p>For examples, please see</p>
<ol>
<li><strong><em>~/Mcalibrator2/subfunctions/colorcalculator/calculator_auto_estimation_linear.m</em></strong></li>
<li><strong><em>~/Mcalibrator2/subfunctions/colorcalculator/calculator_auto_estimation_hybrid.m</em></strong></li>
</ol>
<p><a href="#Menu">return to menu</a></p>
<h1 id="automations-and-scripting-of-mcalibrator2"><a name = "Scripting"> Automations and scripting of Mcalibrator2 </a></h1>
<p>Almost all the display characterization procedures of Mcalibrator2 have been provided as individual MATLAB functions and they are found in the <strong><em>~/Mcalibrator2/subfunctions</em></strong> directory. Therefore, you can easily extract a part of the procedures implemented in Mcalibrator2<br />
and use it in your own display characterization routines.</p>
<p>Here, I will introduce some MATLAB code examples on how to access and use the sub-routines of Mcalibrator2. Hope these samples can help your daily display characterizations.</p>
<ol>
<li><strong><em>Sample 1: run gamma-correction with CRS ColorCAL2</em></strong><br />
(You can find the source in <strong><em>~/Mcalibrator2/scripting_samples/gamma_correction_ColorCAL.m</em></strong>)</li>
</ol>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [lut,xyY]=gamma_correction_ColorCAL(mes_steps,fit_method,num_repeats)

<span class="co">% A sample script to perform display gamma-correction by yourself without Mcalibrator2 GUI window.</span>
<span class="co">% function [lut,xyY]=gamma_correction_ColorCAL(:mes_steps,:fit_method,:num_repeats)</span>
<span class="co">% (: is optional)</span>
<span class="co">%</span>
<span class="co">% A simple script to perform display gamma-correction (grayscale only) using</span>
<span class="co">% Cambridge Research Systems ColorCAL MK2 via a USB connection.</span>
<span class="co">% When you customize the sub-routine to display color patches (DisplayColorWindow),</span>
<span class="co">% you can interact with Psychtoolbox, ViSaGe, or BITS#.</span>
<span class="co">%</span>
<span class="co">% [how to use]</span>
<span class="co">% 1. connect ColorCAL MK2 to computer with a USB cable</span>
<span class="co">% 2. launch MATLAB (32-bit) and go to this directory</span>
<span class="co">% 3. run the gamma-correction script on MATLAB</span>
<span class="co">%    &gt;&gt; lut=gamma_correction_ColorCAL(32)</span>
<span class="co">% 4. results is stored in &#39;gamma_correction_YYMMDD.mat&#39; file</span>
<span class="co">%</span>
<span class="co">% [input]</span>
<span class="co">% mes_steps   : measurement steps. 32 by default.</span>
<span class="co">%               luminance measurement will be performed for video input values</span>
<span class="co">%               defined by linspace(0.0,1.0,mes_steps)</span>
<span class="co">% fit_method  : method to create gamma table, &#39;cbs&#39; by default.</span>
<span class="co">%               one of &#39;gog&#39;,&#39;cbs&#39;,&#39;rcbs&#39;,&#39;pow&#39;,&#39;pow2&#39;,&#39;log&#39;,&#39;lin&#39;, &#39;poly&#39;, &#39;sig&#39;, or &#39;sg&#39;</span>
<span class="co">%               currently, supported methods are</span>
<span class="co">%               &#39;gog&#39;  : gain-offset-gamma model, exponential, based on CRT&#39;s internal model</span>
<span class="co">%               &#39;cbs&#39;  : cubic spline</span>
<span class="co">%               &#39;rcbs&#39; : robust cubic spline</span>
<span class="co">%               &#39;pow&#39;  : power function</span>
<span class="co">%               &#39;pow2&#39; : diff of 2 power functions</span>
<span class="co">%               &#39;log&#39;  : 5th order polynomial fit in log space</span>
<span class="co">%               &#39;lin&#39;  : linear interpolation</span>
<span class="co">%               &#39;poly&#39; : 5th order polynomial fit</span>
<span class="co">%               &#39;sig&#39;  : sigmoid function</span>
<span class="co">%               &#39;wbl&#39;  : Weibull function</span>
<span class="co">%               &#39;gs&#39;   : grid search with robust spline</span>
<span class="co">%                        only valid when numluttbl==length(lum)</span>
<span class="co">%               &#39;gog (gain-offset-gamma model)&#39; by default</span>
<span class="co">%               &#39;cbs (cubic spline)&#39; is also recommneded if the display is LCD, DLP, or EL</span>
<span class="co">%               For details, please see ApplyGammaCorrection.m</span>
<span class="co">% num_repeats : the number of repetitions of the measurements, 1 by default.</span>
<span class="co">%</span>
<span class="co">% [output]</span>
<span class="co">% lut        : the generated Color LookupTable. [1 x 256] matrix.</span>
<span class="co">% xyY        : measured xyY values for each of video input intensities.</span>
<span class="co">%              [4(video input value, x, y, Y) x mes_step] matrix.</span>
<span class="co">%</span>
<span class="co">%</span>
<span class="co">% Created    : &quot;2012-10-31 16:15:32 ban&quot;</span>
<span class="co">% Last Update: &quot;2013-12-18 11:15:35 ban&quot;</span>

<span class="co">% check input variables</span>
if nargin&lt;<span class="fl">1</span> || isempty(mes_steps), mes_steps=<span class="fl">32</span>; end
if nargin&lt;<span class="fl">2</span> || isempty(fit_method), fit_method=<span class="st">&#39;cbs&#39;</span>; end
if nargin&lt;<span class="fl">3</span> || isempty(num_repeats), num_repeats=<span class="fl">1</span>; end

<span class="co">% add path to Mcalibrator2 subfunctions</span>
addpath(genpath(fullfile(pwd,<span class="st">&#39;..&#39;</span>,<span class="st">&#39;subfunctions&#39;</span>)));

<span class="co">% generate directory to save the results</span>
save_dir=fullfile(pwd,<span class="st">&#39;results&#39;</span>);
if ~exist(save_dir,<span class="st">&#39;dir&#39;</span>), mkdir(save_dir); end

<span class="co">% initialize ColorCAL</span>
device=colorcal;
device=device.gen_port();
device=device.initialize();

<span class="co">% display color window for adjusting colorimeter position</span>
fullscr_flg=<span class="fl">1</span>;
fig_id=DisplayColorWindow(<span class="fl">999</span>,fullscr_flg);

disp(<span class="st">&#39; &#39;</span>);
disp(<span class="st">&#39;*******************************************************************&#39;</span>);
disp(<span class="st">&#39;adjust colorimeter position and press OK, then press F5 to proceed.&#39;</span>);
disp(<span class="st">&#39;*******************************************************************&#39;</span>);
disp(<span class="st">&#39; &#39;</span>);
keyboard;

<span class="co">% set colors and mask</span>
colors={<span class="st">&#39;red&#39;</span>,<span class="st">&#39;green&#39;</span>,<span class="st">&#39;blue&#39;</span>,<span class="st">&#39;gray&#39;</span>};
colormask={[<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>],[<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">0</span>],[<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>],[<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>]};

<span class="co">% initializing xyY data structure</span>
xyY=cell(length(colors),<span class="fl">1</span>);
for ii=<span class="fl">1</span>:<span class="fl">1</span>:length(colors)
  xyY{ii}=zeros(<span class="fl">4</span>,mes_steps); <span class="co">% 4 = video-input-values, CIE1931 x, CIE1931 y, and CIE1931 Y.</span>
  xyY{ii}(<span class="fl">1</span>,:)=linspace(<span class="fl">0.0</span>,<span class="fl">1.0</span>,mes_steps);
end

<span class="co">% light measurements, alternatively you can use MeasureCIE1931xyYs function implemented in Mcalibrator2.</span>
for ii=<span class="fl">1</span>:<span class="fl">1</span>:length(colors)
  fprintf(<span class="st">&#39;measuring luminance/chromaticity for %s...&#39;</span>,colors{ii});
  tmpx=zeros(num_repeats,mes_steps); tmpy=zeros(num_repeats,mes_steps); tmpY=zeros(num_repeats,mes_steps);
  for rr=<span class="fl">1</span>:<span class="fl">1</span>:num_repeats
    for nn=<span class="fl">1</span>:<span class="fl">1</span>:mes_steps
      fig_id=DisplayColorWindow(repmat(xyY{ii}(<span class="fl">1</span>,nn),<span class="fl">1</span>,<span class="fl">3</span>).*colormask{ii},fullscr_flg,fig_id);
      [dummy,tmpY(rr,nn),tmpx(rr,nn),tmpy(rr,nn),device]=device.measure();
    end
  end
  xyY{ii}(<span class="fl">2</span>:<span class="fl">4</span>,:)=[mean(tmpx,<span class="fl">1</span>);mean(tmpy,<span class="fl">1</span>);mean(tmpY,<span class="fl">1</span>)];
  clear tmpx tmpy tmpY;
  disp(<span class="st">&#39;done.&#39;</span>);
end

<span class="co">% close color window and release a persistent variable to control figure</span>
DisplayColorWindow(-<span class="fl">999</span>,fullscr_flg,fig_id);

<span class="co">% apply gamma-correction to the measured data</span>
lutnum=<span class="fl">256</span>; monotonic_flg=<span class="fl">1</span>; lowpass_flg=<span class="fl">0</span>; flare_correction_flg=<span class="fl">1</span>; display_flg=<span class="fl">1</span>; save_flg=<span class="fl">0</span>;
lut=cell(length(colors),<span class="fl">1</span>);
for ii=<span class="fl">1</span>:<span class="fl">1</span>:length(colors)
  fprintf(<span class="st">&#39;generating gamma-table for %s...&#39;</span>,colors{ii});
  lut{ii}=ApplyGammaCorrection(xyY{ii}([<span class="fl">1</span>,<span class="fl">4</span>],:),fit_method,lutnum,monotonic_flg,lowpass_flg,flare_correction_flg,display_flg,save_flg);
  movefile(fullfile(pwd,sprintf(<span class="st">&#39;gamma_corr_result_%s.png&#39;</span>,fit_method)),...
           fullfile(save_dir,sprintf(<span class="st">&#39;gamma_corr_result_%s_%s.png&#39;</span>,fit_method,colors{ii})));
  disp(<span class="st">&#39;done.&#39;</span>);
end

<span class="co">% save phosphor xyY as [rx,gx,bx;ry,gy,by;rY,gY,bY]</span>
phosphors=[xyY{<span class="fl">1</span>}(<span class="fl">2</span>:<span class="fl">4</span>,end),xyY{<span class="fl">2</span>}(<span class="fl">2</span>:<span class="fl">4</span>,end),xyY{<span class="fl">3</span>}(<span class="fl">2</span>:<span class="fl">4</span>,end)];

<span class="co">% save the measurement resutls</span>
fprintf(<span class="st">&#39;saving the data...&#39;</span>);
savefname=fullfile(save_dir,sprintf(<span class="st">&#39;gamma_correction_%s.mat&#39;</span>,datestr(now,<span class="st">&#39;yymmdd&#39;</span>)));
save(savefname,<span class="st">&#39;colors&#39;</span>,<span class="st">&#39;colormask&#39;</span>,<span class="st">&#39;lut&#39;</span>,<span class="st">&#39;xyY&#39;</span>,<span class="st">&#39;phosphors&#39;</span>);
disp(<span class="st">&#39;done.&#39;</span>);

<span class="co">% remove path to Mcalibrator2 subfunctions</span>
rmpath(genpath(fullfile(pwd,<span class="st">&#39;..&#39;</span>,<span class="st">&#39;subfunctions&#39;</span>)));

return</code></pre></div>
<ol>
<li><strong><em>Sample 2: run auto chromaticity estimation with CRS ColorCAL2</em></strong><br />
(You can find the source in <strong><em>~/Mcalibrator2/scripting_samples/auto_color_estimation_ColorCAL.m</em></strong>)</li>
</ol>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function estimate=auto_color_estimation_ColorCAL(xyY_want,lut,phosphors)

<span class="co">% A sample script to run the recursive-linear automatic color estimation by yourself without Mcalibrator2 GUI window.</span>
<span class="co">% function estimate=auto_color_estimation_ColorCAL(xyY_want,lut,:phosphors)</span>
<span class="co">% (: is optional)</span>
<span class="co">%</span>
<span class="co">% A simple script to run the recursive-linear automatic color estimation procedure developed</span>
<span class="co">% by H.Ban and H.Yamamoto, using Cambridge Research Systems ColorCAL MK2 via a USB connection.</span>
<span class="co">%</span>
<span class="co">% The details of the algorithm is described in</span>
<span class="co">% Ban, H., &amp; Yamamoto, H. (2013).</span>
<span class="co">% A non-device-specific approach to display characterization based on linear, nonlinear, and hybrid search algorithms.</span>
<span class="co">% Journal of Vision, 13(6):20, 1-26, http://www.journalofvision.org/content/13/6/20, doi:10.1167/13.6.20.</span>
<span class="co">%</span>
<span class="co">% [how to use]</span>
<span class="co">% 1. connect ColorCAL MK2 to computer with a USB cable</span>
<span class="co">% 2. launch MATLAB (32-bit) and go to this directory</span>
<span class="co">% 3. run the auto-calibration script on MATLAB</span>
<span class="co">%    &gt;&gt; estimate=auto_color_estimation_ColorCAL(xyY_want,lut);</span>
<span class="co">% 4. results is stored in &#39;auto_estimation_YYMMDD.mat&#39; file</span>
<span class="co">%</span>
<span class="co">% [input]</span>
<span class="co">% xyY_want   : xyY values we want, [3 x n] matrix</span>
<span class="co">% lut        : color lookup table, [n x 3(r,g,b)] matrix, set lut=[]; if you do not need to use LUTs</span>
<span class="co">% phosphors  : phosphor xyY, [rx,gx,bx;ry,gy,by;rY,gY,bY] (RGB) at max voltage level of the display</span>
<span class="co">%</span>
<span class="co">% [output]</span>
<span class="co">% estimate   : cell structure {n x 1}, holding the estimation results with the variables below</span>
<span class="co">%              .method --- &#39;LUT&#39; or &#39;RGB</span>
<span class="co">%              .wanted_xyY</span>
<span class="co">%              .measured_xyY</span>
<span class="co">%              .residuals --- measured_xyY minus rawxyY</span>
<span class="co">%              .rms --- error</span>
<span class="co">%              .RGB --- RGB values for all the estimations</span>
<span class="co">%              .LUT --- lut index if .method=&#39;LUT&#39;</span>
<span class="co">%              .final_xyY --- the final estimation of xyY</span>
<span class="co">%              .final_RGB --- the final estimation of RGB</span>
<span class="co">%              .final_LUT --- the final estimation of LUT</span>
<span class="co">%</span>
<span class="co">%</span>
<span class="co">% Created    : &quot;2013-12-11 13:15:17 ban&quot;</span>
<span class="co">% Last Update: &quot;2013-12-18 11:18:17 ban&quot;</span>

<span class="co">% check input variables</span>
if nargin&lt;<span class="fl">3</span>, help(mfilename()); return; end

if size(xyY_want,<span class="fl">1</span>)~=<span class="fl">3</span>, error(<span class="st">&#39;xyY_want shold be [3(x,y,Y) x n] matrix. check input variable.&#39;</span>); end
if size(lut,<span class="fl">2</span>)==<span class="fl">1</span>, lut=repmat(lut,<span class="fl">1</span>,<span class="fl">3</span>); end
if size(phosphors,<span class="fl">1</span>)~=<span class="fl">3</span> || size(phosphors,<span class="fl">2</span>)~=<span class="fl">3</span>, error(<span class="st">&#39;phosphors should be [rx,gx,bx;ry,gy,by;rY,gY,bY](3 x 3) matrix. check input variable.&#39;</span>); end

<span class="co">% if lut is empty, generating a linear one</span>
if isempty(lut), lut=repmat(linspace(<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="fl">256</span>),[<span class="fl">3</span>,<span class="fl">1</span>])&#39;; end

<span class="co">% add path to Mcalibrator2 subfunctions</span>
addpath(genpath(fullfile(pwd,<span class="st">&#39;..&#39;</span>,<span class="st">&#39;subfunctions&#39;</span>)));

<span class="co">% generate directory to save the results</span>
save_dir=fullfile(pwd,<span class="st">&#39;results&#39;</span>);
if ~exist(save_dir,<span class="st">&#39;dir&#39;</span>), mkdir(save_dir); end

<span class="co">% initialize ColorCAL</span>
device=colorcal;
device=device.gen_port();
device=device.initialize();

<span class="co">% set display handler</span>
displayhandler=@DisplayColorWindow;

<span class="co">% set options for the recursive linear estimation of RGB video inputs to produce your xyY values</span>
options.iteration=<span class="fl">5</span>;
options.samples=<span class="fl">18</span>;
options.rsmerror=<span class="fl">1</span>; <span class="co">% percent error. the estimation will be terminated when the error is less than this value.</span>
options.ss0=<span class="fl">2.0</span>; <span class="co">% search space, from ss0 to ss1</span>
options.ss1=<span class="fl">1.0</span>;

<span class="co">% run the recursive linear estimation</span>
<span class="co">% you can also select one from the other algorithms implemented in Mcalibrator2 or your own procedures.</span>
fprintf(<span class="st">&#39;optimizing RGB video inputs to produce xyY you want...&#39;</span>);
estimate=AutoColorEstimateLinear(xyY_want,xyY_want,phosphors,[],lut,device,displayhandler,options);
disp(<span class="st">&#39;done.&#39;</span>);

<span class="co">% plotting</span>
fprintf(<span class="st">&#39;Plotting estimated accuracies on the CIE1931 diagram...&#39;</span>);
PlotCIE1931xy([],phosphors,-<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">1</span>);
for mm=<span class="fl">1</span>:<span class="fl">1</span>:size(xyY_want,<span class="fl">2</span>)
  hold on;
  PlotCIE1931xy(xyY_want(<span class="fl">1</span>:<span class="fl">2</span>,mm),phosphors,<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>);
  PlotCIE1931xy(estimate{mm}.final_xyY(<span class="fl">1</span>:<span class="fl">2</span>),phosphors,<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">0</span>);
end
disp(<span class="st">&#39;done.&#39;</span>);

<span class="co">% save the measurement resutls</span>
fprintf(<span class="st">&#39;saving the results...&#39;</span>);
savefname=fullfile(save_dir,sprintf(<span class="st">&#39;auto_estimation_%s.mat&#39;</span>,datestr(now,<span class="st">&#39;yymmdd&#39;</span>)));
save(savefname,<span class="st">&#39;estimate&#39;</span>);
disp(<span class="st">&#39;done.&#39;</span>);

<span class="co">% remove path to Mcalibrator2 subfunctions</span>
rmpath(genpath(fullfile(pwd,<span class="st">&#39;..&#39;</span>,<span class="st">&#39;subfunctions&#39;</span>)));

return</code></pre></div>
<ol>
<li><strong><em>Sample 3: measure RGB phosphors with Admesy BrontesLL</em></strong><br />
(You can find the source in <strong><em>~/Mcalibrator2/scripting_samples/measure_RGBphosphors_brontes.m</em></strong>)</li>
</ol>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [Phosphor,white,flare,mcolors,mcolors_str]=measure_RGBphosphors_brontes(out_fname,integtime,nrepeat)

<span class="co">% A sample script to measure CIE1931 xyY for RGB video input values by yourself without Mcalibrator2 GUI window.</span>
<span class="co">% function [Phosphor,white,flare,mcolors,mcolors_str]=measure_RGBphosphors_brontes(:out_fname,:integtime,:nrepeat)</span>
<span class="co">% (: is optional)</span>
<span class="co">%</span>
<span class="co">% A simple script to measure RGB phosphor chromaticities (at the maximum voltage level)</span>
<span class="co">% using Admesy brontes-LL photometer through a USB connection.</span>
<span class="co">%</span>
<span class="co">% [how to use]</span>
<span class="co">% 1. connect Brontes-LL to computer with a USB cable</span>
<span class="co">% 2. launch MATLAB (32-bit) and go to this directory</span>
<span class="co">% 3. run the measurement script on MATLAB</span>
<span class="co">%    &gt;&gt; measure_RGBphosphors_brontes(&#39;your_output_file_name&#39;)</span>
<span class="co">% 4. results is stored in &#39;your_output_file_name&#39; file</span>
<span class="co">%</span>
<span class="co">% [input]</span>
<span class="co">% out_fname  : output file name, e.g. &#39;left_projector.mat&#39;, &#39;phosphor.mat&#39; by default</span>
<span class="co">% integtime  : integration time in usec, 20000 by default</span>
<span class="co">% nrepeat    : the number of repetitions, 5 by default</span>
<span class="co">%</span>
<span class="co">% [output]</span>
<span class="co">% Phosphor   : RGB phosphor xyY, 3x3 matrix. [Rx,Gx,Bx;Ry,Gy,By;RY,GY,BY]</span>
<span class="co">% white      : CIE1931 xyY for white (RGB=[255,255,255]), [wx;wy;wY]</span>
<span class="co">% flare      : CIE1931 xyY for black (RGB=[  0,  0,  0]), [kx;ky;kY]</span>
<span class="co">% mcolors={[1,0,0],[0,1,0],[0,0,1],[1,1,1],[0,0,0]}; (fixed in this function for simplicity)</span>
<span class="co">% mcolors_str={&#39;red  &#39;,&#39;green&#39;,&#39;blue &#39;,&#39;white&#39;,&#39;black&#39;}; (fixed in this function for simplicity)</span>
<span class="co">%</span>
<span class="co">% [note on chromaticity unit conversion]</span>
<span class="co">%</span>
<span class="co">% Once you get phosphor (and white &amp; flare) matrix, you can convert RGB video input values</span>
<span class="co">% to the corresponding CIE1931 xyY (XYZ, Lab, uv) chromaticity values.</span>
<span class="co">% (To do chromatictiy unit conversion, add path to &#39;subfunction&#39; directory first)</span>
<span class="co">%</span>
<span class="co">% For example, when the target pixel RGB values are RGB=[255,100,64],</span>
<span class="co">%</span>
<span class="co">% 1. to convert RGB pixel values to CIE1931 xyY</span>
<span class="co">% &gt;&gt; xyY = RGB2xyY(RGB./255,Phosphor,[]); % recommended</span>
<span class="co">% or</span>
<span class="co">% &gt;&gt; xyY = RGB2xyY(RGB./255,Phosphor,flare);</span>
<span class="co">%</span>
<span class="co">% 2. to convert xyY to XYZ</span>
<span class="co">% &gt;&gt; XYZ = xyY2XYZ(xyY);</span>
<span class="co">%</span>
<span class="co">% 3. to convert XYZ to Lab (using a Psychtoolbox function)</span>
<span class="co">% &gt;&gt; Lab = lab=XYZToLab(XYZ,xyY2XYZ(white));</span>
<span class="co">%</span>
<span class="co">% 4. to convert xy to uv (using a Psychtoolbox function)</span>
<span class="co">% &gt;&gt; xy = xyY(1:2);</span>
<span class="co">% &gt;&gt; uv = xyTouv(xy,0);</span>
<span class="co">%</span>
<span class="co">%</span>
<span class="co">% Created    : &quot;2012-10-31 16:15:32 ban&quot;</span>
<span class="co">% Last Update: &quot;2013-12-18 11:15:29 ban&quot;</span>

<span class="co">% check input variable</span>
if nargin&lt;<span class="fl">1</span> || isempty(out_fname), out_fname=<span class="st">&#39;phosphor.mat&#39;</span>; end
if nargin&lt;<span class="fl">2</span> || isempty(integtime), integtime=<span class="fl">20000</span>; end
if nargin&lt;<span class="fl">3</span> || isempty(nrepeat), nrepeat=<span class="fl">5</span>; end

if ~strcmp(out_fname(end-<span class="fl">3</span>:end),<span class="st">&#39;.mat&#39;</span>), out_fname=[out_fname,<span class="st">&#39;.mat&#39;</span>]; end

<span class="co">% add path to Mcalibrator2 subfunctions</span>
addpath(genpath(fullfile(pwd,<span class="st">&#39;..&#39;</span>,<span class="st">&#39;subfunctions&#39;</span>)));

<span class="co">% generate directory to save the results</span>
save_dir=fullfile(pwd,<span class="st">&#39;results&#39;</span>);
if ~exist(save_dir,<span class="st">&#39;dir&#39;</span>), mkdir(save_dir); end

<span class="co">% initialize Brontes-LL</span>
device=brontesLL;
device=device.gen_port(<span class="st">&#39;USB0::0x1781::0x0E98::00032::INSTR&#39;</span>);
device=device.initialize(integtime);

<span class="co">% display color window for adjusting colorimeter position</span>
fullscr_flg=<span class="fl">1</span>;
fig_id=DisplayColorWindow(<span class="fl">999</span>,fullscr_flg);

disp(<span class="st">&#39; &#39;</span>);
disp(<span class="st">&#39;*******************************************************************&#39;</span>);
disp(<span class="st">&#39;adjust colorimeter position and press OK, then press F5 to proceed.&#39;</span>);
disp(<span class="st">&#39;*******************************************************************&#39;</span>);
disp(<span class="st">&#39; &#39;</span>);
keyboard;

<span class="co">% measure RGB</span>
mcolors={[<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>],[<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">0</span>],[<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>],[<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>],[<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>]};
mcolors_str={<span class="st">&#39;red  &#39;</span>,<span class="st">&#39;green&#39;</span>,<span class="st">&#39;blue &#39;</span>,<span class="st">&#39;white&#39;</span>,<span class="st">&#39;black&#39;</span>};
Y=zeros(nrepeat,length(mcolors)); x=zeros(nrepeat,length(mcolors)); y=zeros(nrepeat,length(mcolors));
fprintf(<span class="st">&#39;\nmeasuring display chromaticities...\n\n&#39;</span>);
for nn=<span class="fl">1</span>:<span class="fl">1</span>:nrepeat
  for cc=<span class="fl">1</span>:<span class="fl">1</span>:length(mcolors)
    fig_id=DisplayColorWindow(mcolors{cc},fullscr_flg,fig_id);
    [qq,Y(nn,cc),x(nn,cc),y(nn,cc),device]=device.measure(integtime);
  end
end

<span class="co">% display measured values</span>
Y=mean(Y,<span class="fl">1</span>); x=mean(x,<span class="fl">1</span>); y=mean(y,<span class="fl">1</span>);
for cc=<span class="fl">1</span>:<span class="fl">1</span>:length(mcolors)
  fprintf(<span class="st">&#39;%s: CIE1931 xyY = (%f,%f,%f)\n&#39;</span>,mcolors_str{cc},x(cc),y(cc),Y(cc));
end

<span class="co">% close color window and release a persistent variable to control figure</span>
DisplayColorWindow(-<span class="fl">999</span>,fullscr_flg,fig_id);

<span class="co">% RGB phosphor chromaticity, [Rx Gx Bx; Ry Gy By; RY GY BY]</span>
Phosphor=[x(<span class="fl">1</span>),x(<span class="fl">2</span>),x(<span class="fl">3</span>);y(<span class="fl">1</span>),y(<span class="fl">2</span>),y(<span class="fl">3</span>);Y(<span class="fl">1</span>),Y(<span class="fl">2</span>),Y(<span class="fl">3</span>)];

<span class="co">% plotting measured xy values in CIE1931 chromaticity diagram</span>
new_fig_flg=<span class="fl">1</span>; tri_flg=<span class="fl">1</span>; color_flg=<span class="fl">1</span>; marker_type=<span class="fl">1</span>;
PlotCIE1931xy([x(<span class="fl">4</span>);y(<span class="fl">4</span>)],Phosphor,new_fig_flg,tri_flg,color_flg,marker_type);
white=[x(<span class="fl">4</span>);y(<span class="fl">4</span>);Y(<span class="fl">4</span>)];
flare=[x(<span class="fl">5</span>);y(<span class="fl">5</span>);Y(<span class="fl">5</span>)];

<span class="co">% save the measured resutls</span>
fprintf(<span class="st">&#39;saving the results...&#39;</span>);
save(fullfile(save_dir,out_fname),<span class="st">&#39;Phosphor&#39;</span>,<span class="st">&#39;white&#39;</span>,<span class="st">&#39;flare&#39;</span>,<span class="st">&#39;mcolors&#39;</span>,<span class="st">&#39;mcolors_str&#39;</span>);
disp(<span class="st">&#39;done.&#39;</span>);

<span class="co">% remove path to Mcalibrator2 subfunctions</span>
rmpath(genpath(fullfile(pwd,<span class="st">&#39;..&#39;</span>,<span class="st">&#39;subfunctions&#39;</span>)));

return</code></pre></div>
<p><a href="#Menu">return to menu</a></p>
<h1 id="acknowledgments"><a name = "Acknowledgments"> <strong>Acknowledgments</strong> </a></h1>
<p>Mcalibrator2 uses several MATLAB functions distributed by someones directly or modified versions of them. The details are listed as below.<br />
We greatly appreciate for their contributions. We also clearly denote that our Mcalibrator2 suite fulfills all the license requirements to use these tools.</p>
<ul>
<li><p><strong><em>For creating GUI window</em></strong><br />
<strong>tabpanel</strong> : Elmar Tarajan<br />
[ref] [<a href="http://www.mathworks.com/matlabcentral/fileexchange/6996-tabpanel-constructor-v2-8-2010" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/6996-tabpanel-constructor-v2-8-2010</a>](<a href="http://www.mathworks.com/matlabcentral/fileexchange/6996-tabpanel-constructor-v2-8-2010" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/6996-tabpanel-constructor-v2-8-2010</a>)</p></li>
<li><p><strong><em>For creating html documents</em></strong><br />
<strong>m2html</strong> : Guillaume Flandin<br />
[ref] [<a href="http://www.artefact.tk/software/matlab/m2html/" class="uri">http://www.artefact.tk/software/matlab/m2html/</a>](<a href="http://www.artefact.tk/software/matlab/m2html/" class="uri">http://www.artefact.tk/software/matlab/m2html/</a>)</p></li>
<li><p><strong><em>For transforming chromatic values across different units and spaces</em></strong><br />
<em>We appreciate the developer of this tool. The CIE1931 color disk on the Color Calculator tab of Mcalibrator2 was generated based on this tool.</em><br />
<strong>optprop</strong> : Jerker Wagberg<br />
[ref] [<a href="http://www.mathworks.com/matlabcentral/fileexchange/13788-optprop-a-color-properties-toolbox" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/13788-optprop-a-color-properties-toolbox</a>](<a href="http://www.mathworks.com/matlabcentral/fileexchange/13788-optprop-a-color-properties-toolbox" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/13788-optprop-a-color-properties-toolbox</a>)</p></li>
<li><p><strong><em>For filtering raw luminance data</em></strong><br />
<strong>smoothn</strong> : Damien Garcia<br />
[ref] Garcia D, Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics &amp; Data Analysis, 2010.<br />
[ref] [<a href="http://www.mathworks.com/matlabcentral/fileexchange/725-smoothn" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/725-smoothn</a>](<a href="http://www.mathworks.com/matlabcentral/fileexchange/725-smoothn" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/725-smoothn</a>)</p></li>
</ul>
<p><strong>splinefit</strong> : Jonas Lundgren<br />
[ref] [<a href="http://www.mathworks.com/matlabcentral/fileexchange/13812-splinefit" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/13812-splinefit</a>](<a href="http://www.mathworks.com/matlabcentral/fileexchange/13812-splinefit" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/13812-splinefit</a>)</p>
<ul>
<li><p><strong><em>For non-linear estimation of RGB values to produce CIE1931 xyY we want</em></strong><br />
<strong>fminsearchOS</strong> : Olivier Salvado<br />
[ref] Jeffrey C. Lagarias, James A. Reeds, Margaret H. Wright, Paul E. Wright, &quot;Convergence Properties of the Nelder-Mead Simplex Method in Low Dimensions&quot;, SIAM Journal of Optimization, 9(1): p.112-147, 1998.<br />
[ref] [<a href="http://www.mathworks.com/matlabcentral/fileexchange/5157-fminsearch-modifed-for-higher-scale-smooth-function" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/5157-fminsearch-modifed-for-higher-scale-smooth-function</a>](<a href="http://www.mathworks.com/matlabcentral/fileexchange/5157-fminsearch-modifed-for-higher-scale-smooth-function" class="uri">http://www.mathworks.com/matlabcentral/fileexchange/5157-fminsearch-modifed-for-higher-scale-smooth-function</a>)</p></li>
<li><p><strong><em>For very effective optimization/estimation of RGB values to produce CIE1931 xyY we want</em></strong><br />
<strong>iFit toolbox</strong> : E. Farhi et al.<br />
[ref] [<a href="http://ifit.mccode.org/index.html" class="uri">http://ifit.mccode.org/index.html</a>](<a href="http://ifit.mccode.org/index.html" class="uri">http://ifit.mccode.org/index.html</a>)</p></li>
<li><p><strong><em>For maximizing figure window using Windows API when Mcalibrator2 is running on Windows OS</em></strong><br />
<strong>WindowAPI</strong> : Jan Simon<br />
[ref] [<a href="https://jp.mathworks.com/matlabcentral/fileexchange/31437-windowapi" class="uri">https://jp.mathworks.com/matlabcentral/fileexchange/31437-windowapi</a>](<a href="https://jp.mathworks.com/matlabcentral/fileexchange/31437-windowapi" class="uri">https://jp.mathworks.com/matlabcentral/fileexchange/31437-windowapi</a>)</p></li>
<li><p><strong><em>The tool below is not included in Mcalibrator2; you need to install it separately.</em></strong><br />
<em>(Mcalibrator2 can communicate with Psychtoolbox if it is installed.)</em></p></li>
</ul>
<p><strong>Psychtoolbox</strong> : The individual Psychtoolbox core developers,<br />
(c) 1996-2011, David Brainard<br />
(c) 1996-2007, Denis Pelli, Allen Ingling<br />
(c) 2005-2011, Mario Kleiner<br />
Individual major contributors:<br />
(c) 2006 Richard F. Murray<br />
(c) 2008-2011 Diederick C. Niehorster<br />
(c) 2008-2011 Tobias Wolf<br />
[ref] [<a href="http://psychtoolbox.org/HomePage" class="uri">http://psychtoolbox.org/HomePage</a>](<a href="http://psychtoolbox.org/HomePage" class="uri">http://psychtoolbox.org/HomePage</a>)</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="license"><a name = "License"> <strong>License</strong> </a></h1>
<p>Mcalibrator2 --- MATLAB software for display luminance/color characterization<br />
Copyright (c) 2013, Hiroshi Ban, Kyoto University, and National Institute of Information and Communications Technology, Japan.<br />
All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<pre><code>* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the distribution</code></pre>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p><a href="#Menu">return to menu</a></p>
<h1 id="citations-of-mcalibrator2"><a name = "Citations"> <strong>Citations of Mcalibrator2</strong> </a></h1>
<p>If you have spaces in &quot;References&quot; section of your research papers, please allow us to ask you to cite the article below.<br />
If you have no space, please cite somewhere someday next time...Thank you so much.</p>
<ol>
<li><p><strong><em>Ban, H., &amp; Yamamoto, H. (2013).</em></strong><br />
<strong>A non-device-specific approach to display characterization based on linear, nonlinear, and hybrid search algorithms.</strong><br />
Journal of Vision, 13(6):20, 1-26, <a href="http://www.journalofvision.org/content/13/6/20" class="uri">http://www.journalofvision.org/content/13/6/20</a>, <a href="doi:10.1167/13.6.20" class="uri">doi:10.1167/13.6.20</a>.</p></li>
<li><p>(if you have some more space...)<br />
<strong><em>Ban, H., Yamamoto, H., &amp; Ejima, Y. (2006).</em></strong><br />
<strong>Mcalibrator: MATLAB integrated GUI software for display calibration - A proposal of a new color calibration procedure<br />
applicable to a wide range of display devices and evaluation of its efficiency.</strong><br />
Japanese Journal of Psychonomic Science, 24, 149-161.</p></li>
</ol>
<p><a href="#Menu">return to menu</a></p>
<h1 id="todo"><a name = "TODO"> <strong>TODO</strong> </a></h1>
<ol>
<li>Adding some more interfaces to communicate with the other colorimeters (Suppots from someones are always really welcome. Thank you).</li>
<li>Updating Mcalibrator2 PDF manuals using the latest GUI window figures.</li>
<li>Compiling *.m files using the MATLAB compiler so that we can provide a standalone verion of the Mcalibrator2 package.</li>
</ol>
<p><a href="#Menu">return to menu</a></p>
</body>
</html>
